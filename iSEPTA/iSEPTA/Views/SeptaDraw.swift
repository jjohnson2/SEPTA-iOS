//
//  SeptaDraw.swift
//  Septa
//
//  Created by Mark Broski on 9/1/17.
//  Copyright Â© 2017 SEPTA. All rights reserved.
//
//  Generated by PaintCode
//  http://www.paintcodeapp.com
//

import UIKit

public class SeptaDraw: NSObject {

    //// Drawing Methods

    @objc public dynamic class func drawBlueGradientView(frame: CGRect = CGRect(x: 17, y: 49, width: 106, height: 59)) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Color Declarations
        let blueGradientTop = UIColor(red: 0.788, green: 0.890, blue: 1.000, alpha: 1.000)
        let blueGradientBottom = UIColor(red: 0.976, green: 0.988, blue: 1.000, alpha: 1.000)

        //// Gradient Declarations
        let blueGradient = CGGradient(colorsSpace: nil, colors: [blueGradientTop.cgColor, blueGradientBottom.cgColor] as CFArray, locations: [0, 1])!

        //// View Drawing
        let viewRect = CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: frame.height)
        let viewPath = UIBezierPath(rect: viewRect)
        context.saveGState()
        viewPath.addClip()
        context.drawLinearGradient(blueGradient,
                                   start: CGPoint(x: viewRect.midX, y: viewRect.minY),
                                   end: CGPoint(x: viewRect.midX, y: viewRect.maxY),
                                   options: [])
        context.restoreGState()
    }

    @objc public dynamic class func drawBlueGradientCell(frame: CGRect = CGRect(x: 0, y: 0, width: 76, height: 32), shouldFill: Bool = true, enabled: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Color Declarations
        let blueGradientLeft = UIColor(red: 0.871, green: 0.933, blue: 1.000, alpha: 1.000)
        let blueGradientRight = UIColor(red: 0.976, green: 0.988, blue: 1.000, alpha: 1.000)
        let cellBorder = UIColor(red: 0.514, green: 0.635, blue: 0.765, alpha: 1.000)
        let white = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)

        //// Gradient Declarations
        let blueGradientLeftToRight = CGGradient(colorsSpace: nil, colors: [blueGradientLeft.cgColor, blueGradientLeft.blended(withFraction: 0.5, of: blueGradientRight).cgColor, blueGradientRight.cgColor] as CFArray, locations: [0, 0.24, 1])!
        let whiteGradient = CGGradient(colorsSpace: nil, colors: [white.cgColor, UIColor.white.cgColor] as CFArray, locations: [0, 1])!

        //// Shadow Declarations
        let cellShadow = NSShadow()
        cellShadow.shadowColor = UIColor.black.withAlphaComponent(0.14)
        cellShadow.shadowOffset = CGSize(width: 0, height: 0)
        cellShadow.shadowBlurRadius = 2

        //// Variable Declarations
        let cellFill = shouldFill ? blueGradientLeftToRight : whiteGradient
        let opacity: CGFloat = enabled ? 1 : 0.3

        //// Rectangle Drawing
        context.saveGState()
        context.setAlpha(opacity)
        context.beginTransparencyLayer(auxiliaryInfo: nil)

        let rectangleRect = CGRect(x: frame.minX + 0.5, y: frame.minY + 0.5, width: frame.width - 1, height: frame.height - 1)
        let rectanglePath = UIBezierPath(roundedRect: rectangleRect, cornerRadius: 4)
        context.saveGState()
        context.setShadow(offset: cellShadow.shadowOffset, blur: cellShadow.shadowBlurRadius, color: (cellShadow.shadowColor as! UIColor).cgColor)
        context.beginTransparencyLayer(auxiliaryInfo: nil)
        rectanglePath.addClip()
        context.drawLinearGradient(cellFill,
                                   start: CGPoint(x: rectangleRect.maxX, y: rectangleRect.midY),
                                   end: CGPoint(x: rectangleRect.minX, y: rectangleRect.midY),
                                   options: [])
        context.endTransparencyLayer()
        context.restoreGState()

        cellBorder.setStroke()
        rectanglePath.lineWidth = 1
        rectanglePath.lineJoinStyle = .round
        rectanglePath.stroke()

        context.endTransparencyLayer()
        context.restoreGState()
    }

    @objc public dynamic class func drawRedButton(frame: CGRect = CGRect(x: 0, y: 0, width: 125, height: 46), redButtonText: String = "Button Text", enabled: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Color Declarations
        let white = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let redButtonGradientLeft = UIColor(red: 0.502, green: 0.153, blue: 0.063, alpha: 1.000)
        let redButtonGradientRight1 = UIColor(red: 0.843, green: 0.227, blue: 0.071, alpha: 1.000)

        //// Gradient Declarations
        let redButtonGradient = CGGradient(colorsSpace: nil, colors: [redButtonGradientLeft.cgColor, redButtonGradientRight1.cgColor] as CFArray, locations: [0, 1])!

        //// Shadow Declarations
        let cellShadow = NSShadow()
        cellShadow.shadowColor = UIColor.black.withAlphaComponent(0.14)
        cellShadow.shadowOffset = CGSize(width: 0, height: 0)
        cellShadow.shadowBlurRadius = 2

        //// Variable Declarations
        let opacity: CGFloat = enabled ? 1 : 0.3

        //// Rectangle Drawing
        context.saveGState()
        context.setAlpha(opacity)
        context.beginTransparencyLayer(auxiliaryInfo: nil)

        let rectangleRect = CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: frame.height)
        let rectanglePath = UIBezierPath(roundedRect: rectangleRect, cornerRadius: 4)
        context.saveGState()
        context.setShadow(offset: cellShadow.shadowOffset, blur: cellShadow.shadowBlurRadius, color: (cellShadow.shadowColor as! UIColor).cgColor)
        context.beginTransparencyLayer(auxiliaryInfo: nil)
        rectanglePath.addClip()
        let rectangleRotatedPath = UIBezierPath()
        rectangleRotatedPath.append(rectanglePath)
        var rectangleTransform = CGAffineTransform(rotationAngle: -45 * -CGFloat.pi / 180)
        rectangleRotatedPath.apply(rectangleTransform)
        let rectangleBounds = rectangleRotatedPath.cgPath.boundingBoxOfPath
        rectangleTransform = rectangleTransform.inverted()
        context.drawLinearGradient(redButtonGradient,
                                   start: CGPoint(x: rectangleBounds.minX, y: rectangleBounds.midY).applying(rectangleTransform),
                                   end: CGPoint(x: rectangleBounds.maxX, y: rectangleBounds.midY).applying(rectangleTransform),
                                   options: [])
        context.endTransparencyLayer()
        context.restoreGState()

        let rectangleStyle = NSMutableParagraphStyle()
        rectangleStyle.alignment = .center
        let rectangleFontAttributes = [
            .font: UIFont.boldSystemFont(ofSize: UIFont.systemFontSize),
            .foregroundColor: white,
            .paragraphStyle: rectangleStyle,
        ] as [NSAttributedStringKey: Any]

        let rectangleTextHeight: CGFloat = redButtonText.boundingRect(with: CGSize(width: rectangleRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: rectangleFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: rectangleRect)
        redButtonText.draw(in: CGRect(x: rectangleRect.minX, y: rectangleRect.minY + (rectangleRect.height - rectangleTextHeight) / 2, width: rectangleRect.width, height: rectangleTextHeight), withAttributes: rectangleFontAttributes)
        context.restoreGState()

        context.endTransparencyLayer()
        context.restoreGState()
    }

    @objc public dynamic class func drawTripCanvas(frame: CGRect = CGRect(x: 21, y: 26, width: 12, height: 52)) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Color Declarations
        let fillColor = UIColor(red: 0.078, green: 0.294, blue: 0.533, alpha: 1.000)
        let tripCanvasColor = UIColor(red: 0.078, green: 0.294, blue: 0.533, alpha: 1.000)

        //// Subframes
        let destinationMarker: CGRect = CGRect(x: frame.minX + 1, y: frame.minY + frame.height - 15, width: 9, height: 14)

        //// DestinationMarker
        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 3.45))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 3.24, y: destinationMarker.minY + 4.8), controlPoint1: CGPoint(x: destinationMarker.minX + 3.8, y: destinationMarker.minY + 3.45), controlPoint2: CGPoint(x: destinationMarker.minX + 3.24, y: destinationMarker.minY + 4.06))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 6.15), controlPoint1: CGPoint(x: destinationMarker.minX + 3.24, y: destinationMarker.minY + 5.55), controlPoint2: CGPoint(x: destinationMarker.minX + 3.8, y: destinationMarker.minY + 6.15))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 5.76, y: destinationMarker.minY + 4.8), controlPoint1: CGPoint(x: destinationMarker.minX + 5.2, y: destinationMarker.minY + 6.15), controlPoint2: CGPoint(x: destinationMarker.minX + 5.76, y: destinationMarker.minY + 5.55))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 3.45), controlPoint1: CGPoint(x: destinationMarker.minX + 5.76, y: destinationMarker.minY + 4.06), controlPoint2: CGPoint(x: destinationMarker.minX + 5.2, y: destinationMarker.minY + 3.45))
        bezier2Path.addLine(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 3.45))
        bezier2Path.close()
        bezier2Path.move(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 6.73))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 2.7, y: destinationMarker.minY + 4.8), controlPoint1: CGPoint(x: destinationMarker.minX + 3.51, y: destinationMarker.minY + 6.73), controlPoint2: CGPoint(x: destinationMarker.minX + 2.7, y: destinationMarker.minY + 5.87))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 2.88), controlPoint1: CGPoint(x: destinationMarker.minX + 2.7, y: destinationMarker.minY + 3.74), controlPoint2: CGPoint(x: destinationMarker.minX + 3.51, y: destinationMarker.minY + 2.88))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 6.3, y: destinationMarker.minY + 4.8), controlPoint1: CGPoint(x: destinationMarker.minX + 5.49, y: destinationMarker.minY + 2.88), controlPoint2: CGPoint(x: destinationMarker.minX + 6.3, y: destinationMarker.minY + 3.74))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 6.73), controlPoint1: CGPoint(x: destinationMarker.minX + 6.3, y: destinationMarker.minY + 5.87), controlPoint2: CGPoint(x: destinationMarker.minX + 5.49, y: destinationMarker.minY + 6.73))
        bezier2Path.addLine(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 6.73))
        bezier2Path.close()
        bezier2Path.move(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 0.58))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 0.54, y: destinationMarker.minY + 4.82), controlPoint1: CGPoint(x: destinationMarker.minX + 2.32, y: destinationMarker.minY + 0.58), controlPoint2: CGPoint(x: destinationMarker.minX + 0.54, y: destinationMarker.minY + 2.48))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 0.93, y: destinationMarker.minY + 6.66), controlPoint1: CGPoint(x: destinationMarker.minX + 0.54, y: destinationMarker.minY + 5.44), controlPoint2: CGPoint(x: destinationMarker.minX + 0.66, y: destinationMarker.minY + 6.02))
        bezier2Path.addLine(to: CGPoint(x: destinationMarker.minX + 0.99, y: destinationMarker.minY + 6.78))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.46, y: destinationMarker.minY + 12.84), controlPoint1: CGPoint(x: destinationMarker.minX + 1.04, y: destinationMarker.minY + 6.88), controlPoint2: CGPoint(x: destinationMarker.minX + 2.77, y: destinationMarker.minY + 9.9))
        bezier2Path.addLine(to: CGPoint(x: destinationMarker.minX + 4.49, y: destinationMarker.minY + 12.9))
        bezier2Path.addLine(to: CGPoint(x: destinationMarker.minX + 4.53, y: destinationMarker.minY + 12.84))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 8.01, y: destinationMarker.minY + 6.78), controlPoint1: CGPoint(x: destinationMarker.minX + 6.22, y: destinationMarker.minY + 9.91), controlPoint2: CGPoint(x: destinationMarker.minX + 7.95, y: destinationMarker.minY + 6.9))
        bezier2Path.addLine(to: CGPoint(x: destinationMarker.minX + 8.07, y: destinationMarker.minY + 6.66))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 8.46, y: destinationMarker.minY + 4.82), controlPoint1: CGPoint(x: destinationMarker.minX + 8.34, y: destinationMarker.minY + 6.03), controlPoint2: CGPoint(x: destinationMarker.minX + 8.46, y: destinationMarker.minY + 5.44))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 0.58), controlPoint1: CGPoint(x: destinationMarker.minX + 8.46, y: destinationMarker.minY + 2.48), controlPoint2: CGPoint(x: destinationMarker.minX + 6.68, y: destinationMarker.minY + 0.58))
        bezier2Path.addLine(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 0.58))
        bezier2Path.close()
        bezier2Path.move(to: CGPoint(x: destinationMarker.minX + 4.38, y: destinationMarker.minY + 13.82))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 0.56, y: destinationMarker.minY + 7.13), controlPoint1: CGPoint(x: destinationMarker.minX + 4.23, y: destinationMarker.minY + 13.55), controlPoint2: CGPoint(x: destinationMarker.minX + 0.63, y: destinationMarker.minY + 7.27))
        bezier2Path.addLine(to: CGPoint(x: destinationMarker.minX + 0.44, y: destinationMarker.minY + 6.9))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX, y: destinationMarker.minY + 4.82), controlPoint1: CGPoint(x: destinationMarker.minX + 0.14, y: destinationMarker.minY + 6.19), controlPoint2: CGPoint(x: destinationMarker.minX, y: destinationMarker.minY + 5.52))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY), controlPoint1: CGPoint(x: destinationMarker.minX, y: destinationMarker.minY + 2.16), controlPoint2: CGPoint(x: destinationMarker.minX + 2.02, y: destinationMarker.minY))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 9, y: destinationMarker.minY + 4.82), controlPoint1: CGPoint(x: destinationMarker.minX + 6.98, y: destinationMarker.minY), controlPoint2: CGPoint(x: destinationMarker.minX + 9, y: destinationMarker.minY + 2.16))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 8.57, y: destinationMarker.minY + 6.88), controlPoint1: CGPoint(x: destinationMarker.minX + 9, y: destinationMarker.minY + 5.52), controlPoint2: CGPoint(x: destinationMarker.minX + 8.86, y: destinationMarker.minY + 6.17))
        bezier2Path.addLine(to: CGPoint(x: destinationMarker.minX + 8.45, y: destinationMarker.minY + 7.13))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.62, y: destinationMarker.minY + 13.77), controlPoint1: CGPoint(x: destinationMarker.minX + 8.37, y: destinationMarker.minY + 7.28), controlPoint2: CGPoint(x: destinationMarker.minX + 5.75, y: destinationMarker.minY + 11.82))
        bezier2Path.addLine(to: CGPoint(x: destinationMarker.minX + 4.49, y: destinationMarker.minY + 14))
        bezier2Path.addLine(to: CGPoint(x: destinationMarker.minX + 4.38, y: destinationMarker.minY + 13.82))
        bezier2Path.close()
        bezier2Path.usesEvenOddFillRule = true
        fillColor.setFill()
        bezier2Path.fill()

        //// Bezier 3 Drawing
        let bezier3Path = UIBezierPath()
        bezier3Path.move(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 3.45))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 3.24, y: destinationMarker.minY + 4.8), controlPoint1: CGPoint(x: destinationMarker.minX + 3.8, y: destinationMarker.minY + 3.45), controlPoint2: CGPoint(x: destinationMarker.minX + 3.24, y: destinationMarker.minY + 4.06))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 6.15), controlPoint1: CGPoint(x: destinationMarker.minX + 3.24, y: destinationMarker.minY + 5.55), controlPoint2: CGPoint(x: destinationMarker.minX + 3.8, y: destinationMarker.minY + 6.15))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 5.76, y: destinationMarker.minY + 4.8), controlPoint1: CGPoint(x: destinationMarker.minX + 5.2, y: destinationMarker.minY + 6.15), controlPoint2: CGPoint(x: destinationMarker.minX + 5.76, y: destinationMarker.minY + 5.55))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 3.45), controlPoint1: CGPoint(x: destinationMarker.minX + 5.76, y: destinationMarker.minY + 4.06), controlPoint2: CGPoint(x: destinationMarker.minX + 5.2, y: destinationMarker.minY + 3.45))
        bezier3Path.addLine(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 3.45))
        bezier3Path.close()
        bezier3Path.move(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 6.73))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 2.7, y: destinationMarker.minY + 4.8), controlPoint1: CGPoint(x: destinationMarker.minX + 3.51, y: destinationMarker.minY + 6.73), controlPoint2: CGPoint(x: destinationMarker.minX + 2.7, y: destinationMarker.minY + 5.87))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 2.88), controlPoint1: CGPoint(x: destinationMarker.minX + 2.7, y: destinationMarker.minY + 3.74), controlPoint2: CGPoint(x: destinationMarker.minX + 3.51, y: destinationMarker.minY + 2.88))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 6.3, y: destinationMarker.minY + 4.8), controlPoint1: CGPoint(x: destinationMarker.minX + 5.49, y: destinationMarker.minY + 2.88), controlPoint2: CGPoint(x: destinationMarker.minX + 6.3, y: destinationMarker.minY + 3.74))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 6.73), controlPoint1: CGPoint(x: destinationMarker.minX + 6.3, y: destinationMarker.minY + 5.87), controlPoint2: CGPoint(x: destinationMarker.minX + 5.49, y: destinationMarker.minY + 6.73))
        bezier3Path.addLine(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 6.73))
        bezier3Path.close()
        bezier3Path.move(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 0.58))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 0.54, y: destinationMarker.minY + 4.82), controlPoint1: CGPoint(x: destinationMarker.minX + 2.32, y: destinationMarker.minY + 0.58), controlPoint2: CGPoint(x: destinationMarker.minX + 0.54, y: destinationMarker.minY + 2.48))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 0.93, y: destinationMarker.minY + 6.66), controlPoint1: CGPoint(x: destinationMarker.minX + 0.54, y: destinationMarker.minY + 5.44), controlPoint2: CGPoint(x: destinationMarker.minX + 0.66, y: destinationMarker.minY + 6.02))
        bezier3Path.addLine(to: CGPoint(x: destinationMarker.minX + 0.99, y: destinationMarker.minY + 6.78))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.46, y: destinationMarker.minY + 12.84), controlPoint1: CGPoint(x: destinationMarker.minX + 1.04, y: destinationMarker.minY + 6.88), controlPoint2: CGPoint(x: destinationMarker.minX + 2.77, y: destinationMarker.minY + 9.9))
        bezier3Path.addLine(to: CGPoint(x: destinationMarker.minX + 4.49, y: destinationMarker.minY + 12.9))
        bezier3Path.addLine(to: CGPoint(x: destinationMarker.minX + 4.53, y: destinationMarker.minY + 12.84))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 8.01, y: destinationMarker.minY + 6.78), controlPoint1: CGPoint(x: destinationMarker.minX + 6.22, y: destinationMarker.minY + 9.91), controlPoint2: CGPoint(x: destinationMarker.minX + 7.95, y: destinationMarker.minY + 6.9))
        bezier3Path.addLine(to: CGPoint(x: destinationMarker.minX + 8.07, y: destinationMarker.minY + 6.66))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 8.46, y: destinationMarker.minY + 4.82), controlPoint1: CGPoint(x: destinationMarker.minX + 8.34, y: destinationMarker.minY + 6.03), controlPoint2: CGPoint(x: destinationMarker.minX + 8.46, y: destinationMarker.minY + 5.44))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 0.58), controlPoint1: CGPoint(x: destinationMarker.minX + 8.46, y: destinationMarker.minY + 2.48), controlPoint2: CGPoint(x: destinationMarker.minX + 6.68, y: destinationMarker.minY + 0.58))
        bezier3Path.addLine(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 0.58))
        bezier3Path.close()
        bezier3Path.move(to: CGPoint(x: destinationMarker.minX + 4.38, y: destinationMarker.minY + 13.82))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 0.56, y: destinationMarker.minY + 7.13), controlPoint1: CGPoint(x: destinationMarker.minX + 4.23, y: destinationMarker.minY + 13.55), controlPoint2: CGPoint(x: destinationMarker.minX + 0.63, y: destinationMarker.minY + 7.27))
        bezier3Path.addLine(to: CGPoint(x: destinationMarker.minX + 0.44, y: destinationMarker.minY + 6.9))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX, y: destinationMarker.minY + 4.82), controlPoint1: CGPoint(x: destinationMarker.minX + 0.14, y: destinationMarker.minY + 6.19), controlPoint2: CGPoint(x: destinationMarker.minX, y: destinationMarker.minY + 5.52))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY), controlPoint1: CGPoint(x: destinationMarker.minX, y: destinationMarker.minY + 2.16), controlPoint2: CGPoint(x: destinationMarker.minX + 2.02, y: destinationMarker.minY))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 9, y: destinationMarker.minY + 4.82), controlPoint1: CGPoint(x: destinationMarker.minX + 6.98, y: destinationMarker.minY), controlPoint2: CGPoint(x: destinationMarker.minX + 9, y: destinationMarker.minY + 2.16))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 8.57, y: destinationMarker.minY + 6.88), controlPoint1: CGPoint(x: destinationMarker.minX + 9, y: destinationMarker.minY + 5.52), controlPoint2: CGPoint(x: destinationMarker.minX + 8.86, y: destinationMarker.minY + 6.17))
        bezier3Path.addLine(to: CGPoint(x: destinationMarker.minX + 8.45, y: destinationMarker.minY + 7.13))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.62, y: destinationMarker.minY + 13.77), controlPoint1: CGPoint(x: destinationMarker.minX + 8.37, y: destinationMarker.minY + 7.28), controlPoint2: CGPoint(x: destinationMarker.minX + 5.75, y: destinationMarker.minY + 11.82))
        bezier3Path.addLine(to: CGPoint(x: destinationMarker.minX + 4.49, y: destinationMarker.minY + 14))
        bezier3Path.addLine(to: CGPoint(x: destinationMarker.minX + 4.38, y: destinationMarker.minY + 13.82))
        bezier3Path.close()
        tripCanvasColor.setStroke()
        bezier3Path.lineWidth = 0.3
        bezier3Path.stroke()

        //// TripStart Drawing
        let tripStartPath = UIBezierPath(ovalIn: CGRect(x: frame.minX + 1, y: frame.minY + 1, width: 9, height: 9))
        tripCanvasColor.setStroke()
        tripStartPath.lineWidth = 1
        tripStartPath.stroke()

        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: frame.minX + 5.43, y: frame.minY + 9.92))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 5.43, y: frame.maxY - 15.99))
        tripCanvasColor.setStroke()
        bezierPath.lineWidth = 1
        context.saveGState()
        context.setLineDash(phase: 0, lengths: [2, 2])
        bezierPath.stroke()
        context.restoreGState()
    }

    @objc public dynamic class func drawAlertView(alertViewFrame: CGRect = CGRect(x: 0, y: 0, width: 100, height: 100)) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Color Declarations
        let alertBurntOrange1 = UIColor(red: 0.800, green: 0.320, blue: 0.320, alpha: 1.000)
        let alertBurntOrange2 = UIColor(red: 0.851, green: 0.388, blue: 0.251, alpha: 1.000)
        let alertBurntOrange3 = UIColor(red: 0.914, green: 0.541, blue: 0.427, alpha: 1.000)
        let alertBurntOrange4 = UIColor(red: 0.961, green: 0.694, blue: 0.612, alpha: 1.000)
        let alertBurntOrange5 = UIColor(red: 0.988, green: 0.847, blue: 0.800, alpha: 1.000)

        //// Gradient Declarations
        let alertOrange = CGGradient(colorsSpace: nil, colors: [alertBurntOrange1.cgColor, alertBurntOrange2.cgColor, alertBurntOrange3.cgColor, alertBurntOrange4.cgColor, alertBurntOrange5.cgColor, UIColor.white.cgColor] as CFArray, locations: [0, 0.2, 0.4, 0.6, 0.76, 1])!

        //// Rectangle Drawing
        context.saveGState()
        context.setAlpha(0.2)

        let rectangleRect = CGRect(x: alertViewFrame.minX, y: alertViewFrame.minY, width: alertViewFrame.width, height: alertViewFrame.height)
        let rectanglePath = UIBezierPath(rect: rectangleRect)
        context.saveGState()
        rectanglePath.addClip()
        context.drawLinearGradient(alertOrange,
                                   start: CGPoint(x: rectangleRect.maxX, y: rectangleRect.midY),
                                   end: CGPoint(x: rectangleRect.minX, y: rectangleRect.midY),
                                   options: [])
        context.restoreGState()

        context.restoreGState()
    }

    @objc public dynamic class func drawSchedulesJumpToNextToArrive(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 128, height: 30), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 128, height: 30), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 128, y: resizedFrame.height / 30)

        //// Color Declarations
        let fillColor = UIColor(red: 0.078, green: 0.294, blue: 0.533, alpha: 1.000)
        let fillColor2 = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let blueTextColor = UIColor(red: 0.078, green: 0.294, blue: 0.533, alpha: 1.000)

        //// nextToArriveTabbarSelected.pdf Group
        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 9.24, y: 6.09, width: 20.1, height: 19.1))
        fillColor.setFill()
        ovalPath.fill()

        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 19.4, y: 17.53))
        bezierPath.addCurve(to: CGPoint(x: 17.28, y: 15.49), controlPoint1: CGPoint(x: 18.23, y: 17.53), controlPoint2: CGPoint(x: 17.28, y: 16.62))
        bezierPath.addCurve(to: CGPoint(x: 19.4, y: 13.44), controlPoint1: CGPoint(x: 17.28, y: 14.36), controlPoint2: CGPoint(x: 18.23, y: 13.44))
        bezierPath.addCurve(to: CGPoint(x: 20.31, y: 13.65), controlPoint1: CGPoint(x: 19.71, y: 13.44), controlPoint2: CGPoint(x: 20.02, y: 13.51))
        bezierPath.addLine(to: CGPoint(x: 23.01, y: 11.05))
        bezierPath.addCurve(to: CGPoint(x: 23.54, y: 10.84), controlPoint1: CGPoint(x: 23.15, y: 10.91), controlPoint2: CGPoint(x: 23.34, y: 10.84))
        bezierPath.addCurve(to: CGPoint(x: 24.08, y: 11.05), controlPoint1: CGPoint(x: 23.74, y: 10.84), controlPoint2: CGPoint(x: 23.93, y: 10.91))
        bezierPath.addCurve(to: CGPoint(x: 24.08, y: 12.09), controlPoint1: CGPoint(x: 24.37, y: 11.34), controlPoint2: CGPoint(x: 24.37, y: 11.8))
        bezierPath.addLine(to: CGPoint(x: 21.35, y: 14.72))
        bezierPath.addCurve(to: CGPoint(x: 21.51, y: 15.49), controlPoint1: CGPoint(x: 21.46, y: 14.97), controlPoint2: CGPoint(x: 21.51, y: 15.23))
        bezierPath.addCurve(to: CGPoint(x: 19.4, y: 17.53), controlPoint1: CGPoint(x: 21.51, y: 16.62), controlPoint2: CGPoint(x: 20.56, y: 17.53))
        bezierPath.close()
        bezierPath.usesEvenOddFillRule = true
        fillColor2.setFill()
        bezierPath.fill()

        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: 17.82, y: 6.06))
        bezier2Path.addCurve(to: CGPoint(x: 17.28, y: 5.49), controlPoint1: CGPoint(x: 17.52, y: 6.06), controlPoint2: CGPoint(x: 17.28, y: 5.8))
        bezier2Path.addLine(to: CGPoint(x: 17.28, y: 5.12))
        bezier2Path.addCurve(to: CGPoint(x: 18.22, y: 4.14), controlPoint1: CGPoint(x: 17.28, y: 4.58), controlPoint2: CGPoint(x: 17.7, y: 4.14))
        bezier2Path.addLine(to: CGPoint(x: 20.35, y: 4.14))
        bezier2Path.addCurve(to: CGPoint(x: 21.29, y: 5.12), controlPoint1: CGPoint(x: 20.87, y: 4.14), controlPoint2: CGPoint(x: 21.29, y: 4.58))
        bezier2Path.addLine(to: CGPoint(x: 21.29, y: 5.49))
        bezier2Path.addCurve(to: CGPoint(x: 20.75, y: 6.06), controlPoint1: CGPoint(x: 21.29, y: 5.8), controlPoint2: CGPoint(x: 21.05, y: 6.06))
        bezier2Path.addLine(to: CGPoint(x: 17.82, y: 6.06))
        bezier2Path.close()
        bezier2Path.usesEvenOddFillRule = true
        fillColor.setFill()
        bezier2Path.fill()

        //// Bezier 3 Drawing
        let bezier3Path = UIBezierPath()
        bezier3Path.move(to: CGPoint(x: 2.85, y: 16.58))
        bezier3Path.addCurve(to: CGPoint(x: 2.24, y: 16.1), controlPoint1: CGPoint(x: 2.51, y: 16.58), controlPoint2: CGPoint(x: 2.24, y: 16.36))
        bezier3Path.addCurve(to: CGPoint(x: 2.85, y: 15.62), controlPoint1: CGPoint(x: 2.24, y: 15.84), controlPoint2: CGPoint(x: 2.51, y: 15.62))
        bezier3Path.addLine(to: CGPoint(x: 7.65, y: 15.62))
        bezier3Path.addCurve(to: CGPoint(x: 8.26, y: 16.1), controlPoint1: CGPoint(x: 7.98, y: 15.62), controlPoint2: CGPoint(x: 8.26, y: 15.84))
        bezier3Path.addCurve(to: CGPoint(x: 7.65, y: 16.58), controlPoint1: CGPoint(x: 8.26, y: 16.36), controlPoint2: CGPoint(x: 7.98, y: 16.58))
        bezier3Path.addLine(to: CGPoint(x: 2.85, y: 16.58))
        bezier3Path.close()
        bezier3Path.usesEvenOddFillRule = true
        fillColor.setFill()
        bezier3Path.fill()

        //// Bezier 4 Drawing
        let bezier4Path = UIBezierPath()
        bezier4Path.move(to: CGPoint(x: 3.89, y: 20.4))
        bezier4Path.addCurve(to: CGPoint(x: 3.24, y: 19.93), controlPoint1: CGPoint(x: 3.53, y: 20.4), controlPoint2: CGPoint(x: 3.24, y: 20.19))
        bezier4Path.addCurve(to: CGPoint(x: 3.89, y: 19.45), controlPoint1: CGPoint(x: 3.24, y: 19.66), controlPoint2: CGPoint(x: 3.53, y: 19.45))
        bezier4Path.addLine(to: CGPoint(x: 7.61, y: 19.45))
        bezier4Path.addCurve(to: CGPoint(x: 8.26, y: 19.93), controlPoint1: CGPoint(x: 7.97, y: 19.45), controlPoint2: CGPoint(x: 8.26, y: 19.66))
        bezier4Path.addCurve(to: CGPoint(x: 7.61, y: 20.4), controlPoint1: CGPoint(x: 8.26, y: 20.19), controlPoint2: CGPoint(x: 7.97, y: 20.4))
        bezier4Path.addLine(to: CGPoint(x: 3.89, y: 20.4))
        bezier4Path.close()
        bezier4Path.usesEvenOddFillRule = true
        fillColor.setFill()
        bezier4Path.fill()

        //// Bezier 5 Drawing
        let bezier5Path = UIBezierPath()
        bezier5Path.move(to: CGPoint(x: 3.89, y: 12.75))
        bezier5Path.addCurve(to: CGPoint(x: 3.24, y: 12.27), controlPoint1: CGPoint(x: 3.53, y: 12.75), controlPoint2: CGPoint(x: 3.24, y: 12.54))
        bezier5Path.addCurve(to: CGPoint(x: 3.89, y: 11.79), controlPoint1: CGPoint(x: 3.24, y: 12.01), controlPoint2: CGPoint(x: 3.53, y: 11.79))
        bezier5Path.addLine(to: CGPoint(x: 7.61, y: 11.79))
        bezier5Path.addCurve(to: CGPoint(x: 8.26, y: 12.27), controlPoint1: CGPoint(x: 7.97, y: 11.79), controlPoint2: CGPoint(x: 8.26, y: 12.01))
        bezier5Path.addCurve(to: CGPoint(x: 7.61, y: 12.75), controlPoint1: CGPoint(x: 8.26, y: 12.54), controlPoint2: CGPoint(x: 7.97, y: 12.75))
        bezier5Path.addLine(to: CGPoint(x: 3.89, y: 12.75))
        bezier5Path.close()
        bezier5Path.usesEvenOddFillRule = true
        fillColor.setFill()
        bezier5Path.fill()

        //// nextToArriveLabel Drawing
        let nextToArriveLabelRect = CGRect(x: 39.12, y: 2.12, width: 79.17, height: 24.06)
        let nextToArriveLabelTextContent = "Next to Arrive\nfor this Route"
        let nextToArriveLabelStyle = NSMutableParagraphStyle()
        nextToArriveLabelStyle.alignment = .left
        let nextToArriveLabelFontAttributes = [
            .font: UIFont.systemFont(ofSize: 11, weight: UIFont.Weight.medium),
            .foregroundColor: blueTextColor,
            .paragraphStyle: nextToArriveLabelStyle,
        ] as [NSAttributedStringKey: Any]

        let nextToArriveLabelTextHeight: CGFloat = nextToArriveLabelTextContent.boundingRect(with: CGSize(width: nextToArriveLabelRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: nextToArriveLabelFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: nextToArriveLabelRect)
        nextToArriveLabelTextContent.draw(in: CGRect(x: nextToArriveLabelRect.minX, y: nextToArriveLabelRect.minY + (nextToArriveLabelRect.height - nextToArriveLabelTextHeight) / 2, width: nextToArriveLabelRect.width, height: nextToArriveLabelTextHeight), withAttributes: nextToArriveLabelFontAttributes)
        context.restoreGState()

        //// Bezier 9 Drawing
        let bezier9Path = UIBezierPath()
        UIColor.black.setStroke()
        bezier9Path.lineWidth = 1
        bezier9Path.stroke()

        //// Bezier 10 Drawing
        let bezier10Path = UIBezierPath()
        bezier10Path.move(to: CGPoint(x: 118.16, y: 10.71))
        bezier10Path.addLine(to: CGPoint(x: 124.45, y: 16.18))
        bezier10Path.addLine(to: CGPoint(x: 118.2, y: 21.59))
        blueTextColor.setStroke()
        bezier10Path.lineWidth = 1
        bezier10Path.stroke()

        context.restoreGState()
    }

    @objc(SeptaDrawResizingBehavior)
    public enum ResizingBehavior: Int {
        case aspectFit /// The content is proportionally resized to fit into the target rectangle.
        case aspectFill /// The content is proportionally resized to completely fill the target rectangle.
        case stretch /// The content is stretched to match the entire target rectangle.
        case center /// The content is centered in the target rectangle, but it is NOT resized.

        public func apply(rect: CGRect, target: CGRect) -> CGRect {
            if rect == target || target == CGRect.zero {
                return rect
            }

            var scales = CGSize.zero
            scales.width = abs(target.width / rect.width)
            scales.height = abs(target.height / rect.height)

            switch self {
            case .aspectFit:
                scales.width = min(scales.width, scales.height)
                scales.height = scales.width
            case .aspectFill:
                scales.width = max(scales.width, scales.height)
                scales.height = scales.width
            case .stretch:
                break
            case .center:
                scales.width = 1
                scales.height = 1
            }

            var result = rect.standardized
            result.size.width *= scales.width
            result.size.height *= scales.height
            result.origin.x = target.minX + (target.width - result.width) / 2
            result.origin.y = target.minY + (target.height - result.height) / 2
            return result
        }
    }
}

private extension UIColor {
    func blended(withFraction fraction: CGFloat, of color: UIColor) -> UIColor {
        var r1: CGFloat = 1, g1: CGFloat = 1, b1: CGFloat = 1, a1: CGFloat = 1
        var r2: CGFloat = 1, g2: CGFloat = 1, b2: CGFloat = 1, a2: CGFloat = 1

        getRed(&r1, green: &g1, blue: &b1, alpha: &a1)
        color.getRed(&r2, green: &g2, blue: &b2, alpha: &a2)

        return UIColor(red: r1 * (1 - fraction) + r2 * fraction,
                       green: g1 * (1 - fraction) + g2 * fraction,
                       blue: b1 * (1 - fraction) + b2 * fraction,
                       alpha: a1 * (1 - fraction) + a2 * fraction)
    }
}
