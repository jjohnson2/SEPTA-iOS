//
//  SeptaDraw.swift
//  Septa
//
//  Created by Mark Broski on 9/16/17.
//  Copyright Â© 2017 SEPTA. All rights reserved.
//
//  Generated by PaintCode
//  http://www.paintcodeapp.com
//

import UIKit

public class SeptaDraw: NSObject {

    //// Drawing Methods

    @objc public dynamic class func drawBlueGradientView(frame: CGRect = CGRect(x: 17, y: 49, width: 106, height: 59)) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Color Declarations
        let blueGradientTop = UIColor(red: 0.788, green: 0.890, blue: 1.000, alpha: 1.000)
        let blueGradientBottom = UIColor(red: 0.976, green: 0.988, blue: 1.000, alpha: 1.000)

        //// Gradient Declarations
        let blueGradient = CGGradient(colorsSpace: nil, colors: [blueGradientTop.cgColor, blueGradientBottom.cgColor] as CFArray, locations: [0, 1])!

        //// View Drawing
        let viewRect = CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: frame.height)
        let viewPath = UIBezierPath(rect: viewRect)
        context.saveGState()
        viewPath.addClip()
        context.drawLinearGradient(blueGradient,
                                   start: CGPoint(x: viewRect.midX, y: viewRect.minY),
                                   end: CGPoint(x: viewRect.midX, y: viewRect.maxY),
                                   options: [])
        context.restoreGState()
    }

    @objc public dynamic class func drawBlueGradientCell(frame: CGRect = CGRect(x: 0, y: 0, width: 76, height: 32), shouldFill: Bool = true, enabled: Bool = false) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Color Declarations
        let blueGradientLeft = UIColor(red: 0.871, green: 0.933, blue: 1.000, alpha: 1.000)
        let blueGradientRight = UIColor(red: 0.976, green: 0.988, blue: 1.000, alpha: 1.000)
        let cellBorder = UIColor(red: 0.514, green: 0.635, blue: 0.765, alpha: 1.000)
        let white = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)

        //// Gradient Declarations
        let blueGradientLeftToRight = CGGradient(colorsSpace: nil, colors: [blueGradientLeft.cgColor, blueGradientLeft.blended(withFraction: 0.5, of: blueGradientRight).cgColor, blueGradientRight.cgColor] as CFArray, locations: [0, 0.24, 1])!
        let whiteGradient = CGGradient(colorsSpace: nil, colors: [white.cgColor, UIColor.white.cgColor] as CFArray, locations: [0, 1])!

        //// Shadow Declarations
        let cellShadow = NSShadow()
        cellShadow.shadowColor = UIColor.black.withAlphaComponent(0.14)
        cellShadow.shadowOffset = CGSize(width: 0, height: 0)
        cellShadow.shadowBlurRadius = 2

        //// Variable Declarations
        let cellFill = shouldFill ? blueGradientLeftToRight : whiteGradient
        let opacity: CGFloat = enabled ? 1 : 0.3

        //// Rectangle Drawing
        context.saveGState()
        context.setAlpha(opacity)
        context.beginTransparencyLayer(auxiliaryInfo: nil)

        let rectangleRect = CGRect(x: frame.minX + 0.5, y: frame.minY + 0.5, width: frame.width - 1, height: frame.height - 1)
        let rectanglePath = UIBezierPath(roundedRect: rectangleRect, cornerRadius: 4)
        context.saveGState()
        context.setShadow(offset: cellShadow.shadowOffset, blur: cellShadow.shadowBlurRadius, color: (cellShadow.shadowColor as! UIColor).cgColor)
        context.beginTransparencyLayer(auxiliaryInfo: nil)
        rectanglePath.addClip()
        context.drawLinearGradient(cellFill,
                                   start: CGPoint(x: rectangleRect.maxX, y: rectangleRect.midY),
                                   end: CGPoint(x: rectangleRect.minX, y: rectangleRect.midY),
                                   options: [])
        context.endTransparencyLayer()
        context.restoreGState()

        cellBorder.setStroke()
        rectanglePath.lineWidth = 1
        rectanglePath.lineJoinStyle = .round
        rectanglePath.stroke()

        context.endTransparencyLayer()
        context.restoreGState()
    }

    @objc public dynamic class func drawRedButton(frame: CGRect = CGRect(x: 0, y: 0, width: 125, height: 46), redButtonText: String = "Button Text", enabled: Bool = false, buttonHighlighted: Bool = false) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Color Declarations
        let white = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let redButtonGradientLeft = UIColor(red: 0.502, green: 0.153, blue: 0.063, alpha: 1.000)
        let redButtonGradientRight1 = UIColor(red: 0.843, green: 0.227, blue: 0.071, alpha: 1.000)
        let buttonHighlight = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 0.078)
        let buttonDefault = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.000)

        //// Gradient Declarations
        let redButtonGradient = CGGradient(colorsSpace: nil, colors: [redButtonGradientLeft.cgColor, redButtonGradientRight1.cgColor] as CFArray, locations: [0, 1])!

        //// Shadow Declarations
        let cellShadow = NSShadow()
        cellShadow.shadowColor = UIColor.black.withAlphaComponent(0.14)
        cellShadow.shadowOffset = CGSize(width: 0, height: 0)
        cellShadow.shadowBlurRadius = 2

        //// Variable Declarations
        let opacity: CGFloat = enabled ? 1 : 0.3
        let buttonHighlightedColor = buttonHighlighted ? buttonHighlight : buttonDefault

        //// Rectangle Drawing
        context.saveGState()
        context.setAlpha(opacity)
        context.beginTransparencyLayer(auxiliaryInfo: nil)

        let rectangleRect = CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: frame.height)
        let rectanglePath = UIBezierPath(roundedRect: rectangleRect, cornerRadius: 4)
        context.saveGState()
        context.setShadow(offset: cellShadow.shadowOffset, blur: cellShadow.shadowBlurRadius, color: (cellShadow.shadowColor as! UIColor).cgColor)
        context.beginTransparencyLayer(auxiliaryInfo: nil)
        rectanglePath.addClip()
        let rectangleRotatedPath = UIBezierPath()
        rectangleRotatedPath.append(rectanglePath)
        var rectangleTransform = CGAffineTransform(rotationAngle: -45 * -CGFloat.pi / 180)
        rectangleRotatedPath.apply(rectangleTransform)
        let rectangleBounds = rectangleRotatedPath.cgPath.boundingBoxOfPath
        rectangleTransform = rectangleTransform.inverted()
        context.drawLinearGradient(redButtonGradient,
                                   start: CGPoint(x: rectangleBounds.minX, y: rectangleBounds.midY).applying(rectangleTransform),
                                   end: CGPoint(x: rectangleBounds.maxX, y: rectangleBounds.midY).applying(rectangleTransform),
                                   options: [])
        context.endTransparencyLayer()
        context.restoreGState()

        let rectangleStyle = NSMutableParagraphStyle()
        rectangleStyle.alignment = .center
        let rectangleFontAttributes = [
            .font: UIFont.boldSystemFont(ofSize: UIFont.systemFontSize),
            .foregroundColor: white,
            .paragraphStyle: rectangleStyle,
        ] as [NSAttributedStringKey: Any]

        let rectangleTextHeight: CGFloat = redButtonText.boundingRect(with: CGSize(width: rectangleRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: rectangleFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: rectangleRect)
        redButtonText.draw(in: CGRect(x: rectangleRect.minX, y: rectangleRect.minY + (rectangleRect.height - rectangleTextHeight) / 2, width: rectangleRect.width, height: rectangleTextHeight), withAttributes: rectangleFontAttributes)
        context.restoreGState()

        context.endTransparencyLayer()
        context.restoreGState()

        //// Rectangle 2 Drawing
        let rectangle2Path = UIBezierPath(roundedRect: CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: frame.height), cornerRadius: 4)
        context.saveGState()
        context.setShadow(offset: cellShadow.shadowOffset, blur: cellShadow.shadowBlurRadius, color: (cellShadow.shadowColor as! UIColor).cgColor)
        buttonHighlightedColor.setFill()
        rectangle2Path.fill()
        context.restoreGState()
    }

    @objc public dynamic class func drawVerticalDottedTripGraphic(frame: CGRect = CGRect(x: 21, y: 26, width: 10, height: 52)) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Color Declarations
        let fillColor = UIColor(red: 0.078, green: 0.294, blue: 0.533, alpha: 1.000)
        let tripCanvasColor = UIColor(red: 0.078, green: 0.294, blue: 0.533, alpha: 1.000)

        //// Subframes
        let destinationMarker: CGRect = CGRect(x: frame.minX + 0.5, y: frame.minY + frame.height - 15, width: 9, height: 14)

        //// DestinationMarker
        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 3.45))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 3.24, y: destinationMarker.minY + 4.8), controlPoint1: CGPoint(x: destinationMarker.minX + 3.8, y: destinationMarker.minY + 3.45), controlPoint2: CGPoint(x: destinationMarker.minX + 3.24, y: destinationMarker.minY + 4.06))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 6.15), controlPoint1: CGPoint(x: destinationMarker.minX + 3.24, y: destinationMarker.minY + 5.55), controlPoint2: CGPoint(x: destinationMarker.minX + 3.8, y: destinationMarker.minY + 6.15))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 5.76, y: destinationMarker.minY + 4.8), controlPoint1: CGPoint(x: destinationMarker.minX + 5.2, y: destinationMarker.minY + 6.15), controlPoint2: CGPoint(x: destinationMarker.minX + 5.76, y: destinationMarker.minY + 5.55))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 3.45), controlPoint1: CGPoint(x: destinationMarker.minX + 5.76, y: destinationMarker.minY + 4.06), controlPoint2: CGPoint(x: destinationMarker.minX + 5.2, y: destinationMarker.minY + 3.45))
        bezier2Path.addLine(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 3.45))
        bezier2Path.close()
        bezier2Path.move(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 6.73))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 2.7, y: destinationMarker.minY + 4.8), controlPoint1: CGPoint(x: destinationMarker.minX + 3.51, y: destinationMarker.minY + 6.73), controlPoint2: CGPoint(x: destinationMarker.minX + 2.7, y: destinationMarker.minY + 5.87))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 2.88), controlPoint1: CGPoint(x: destinationMarker.minX + 2.7, y: destinationMarker.minY + 3.74), controlPoint2: CGPoint(x: destinationMarker.minX + 3.51, y: destinationMarker.minY + 2.88))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 6.3, y: destinationMarker.minY + 4.8), controlPoint1: CGPoint(x: destinationMarker.minX + 5.49, y: destinationMarker.minY + 2.88), controlPoint2: CGPoint(x: destinationMarker.minX + 6.3, y: destinationMarker.minY + 3.74))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 6.73), controlPoint1: CGPoint(x: destinationMarker.minX + 6.3, y: destinationMarker.minY + 5.87), controlPoint2: CGPoint(x: destinationMarker.minX + 5.49, y: destinationMarker.minY + 6.73))
        bezier2Path.addLine(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 6.73))
        bezier2Path.close()
        bezier2Path.move(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 0.58))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 0.54, y: destinationMarker.minY + 4.82), controlPoint1: CGPoint(x: destinationMarker.minX + 2.32, y: destinationMarker.minY + 0.58), controlPoint2: CGPoint(x: destinationMarker.minX + 0.54, y: destinationMarker.minY + 2.48))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 0.93, y: destinationMarker.minY + 6.66), controlPoint1: CGPoint(x: destinationMarker.minX + 0.54, y: destinationMarker.minY + 5.44), controlPoint2: CGPoint(x: destinationMarker.minX + 0.66, y: destinationMarker.minY + 6.02))
        bezier2Path.addLine(to: CGPoint(x: destinationMarker.minX + 0.99, y: destinationMarker.minY + 6.78))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.46, y: destinationMarker.minY + 12.84), controlPoint1: CGPoint(x: destinationMarker.minX + 1.04, y: destinationMarker.minY + 6.88), controlPoint2: CGPoint(x: destinationMarker.minX + 2.77, y: destinationMarker.minY + 9.9))
        bezier2Path.addLine(to: CGPoint(x: destinationMarker.minX + 4.49, y: destinationMarker.minY + 12.9))
        bezier2Path.addLine(to: CGPoint(x: destinationMarker.minX + 4.53, y: destinationMarker.minY + 12.84))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 8.01, y: destinationMarker.minY + 6.78), controlPoint1: CGPoint(x: destinationMarker.minX + 6.22, y: destinationMarker.minY + 9.91), controlPoint2: CGPoint(x: destinationMarker.minX + 7.95, y: destinationMarker.minY + 6.9))
        bezier2Path.addLine(to: CGPoint(x: destinationMarker.minX + 8.07, y: destinationMarker.minY + 6.66))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 8.46, y: destinationMarker.minY + 4.82), controlPoint1: CGPoint(x: destinationMarker.minX + 8.34, y: destinationMarker.minY + 6.03), controlPoint2: CGPoint(x: destinationMarker.minX + 8.46, y: destinationMarker.minY + 5.44))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 0.58), controlPoint1: CGPoint(x: destinationMarker.minX + 8.46, y: destinationMarker.minY + 2.48), controlPoint2: CGPoint(x: destinationMarker.minX + 6.68, y: destinationMarker.minY + 0.58))
        bezier2Path.addLine(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 0.58))
        bezier2Path.close()
        bezier2Path.move(to: CGPoint(x: destinationMarker.minX + 4.38, y: destinationMarker.minY + 13.82))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 0.56, y: destinationMarker.minY + 7.13), controlPoint1: CGPoint(x: destinationMarker.minX + 4.23, y: destinationMarker.minY + 13.55), controlPoint2: CGPoint(x: destinationMarker.minX + 0.63, y: destinationMarker.minY + 7.27))
        bezier2Path.addLine(to: CGPoint(x: destinationMarker.minX + 0.44, y: destinationMarker.minY + 6.9))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX, y: destinationMarker.minY + 4.82), controlPoint1: CGPoint(x: destinationMarker.minX + 0.14, y: destinationMarker.minY + 6.19), controlPoint2: CGPoint(x: destinationMarker.minX, y: destinationMarker.minY + 5.52))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY), controlPoint1: CGPoint(x: destinationMarker.minX, y: destinationMarker.minY + 2.16), controlPoint2: CGPoint(x: destinationMarker.minX + 2.02, y: destinationMarker.minY))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 9, y: destinationMarker.minY + 4.82), controlPoint1: CGPoint(x: destinationMarker.minX + 6.98, y: destinationMarker.minY), controlPoint2: CGPoint(x: destinationMarker.minX + 9, y: destinationMarker.minY + 2.16))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 8.57, y: destinationMarker.minY + 6.88), controlPoint1: CGPoint(x: destinationMarker.minX + 9, y: destinationMarker.minY + 5.52), controlPoint2: CGPoint(x: destinationMarker.minX + 8.86, y: destinationMarker.minY + 6.17))
        bezier2Path.addLine(to: CGPoint(x: destinationMarker.minX + 8.45, y: destinationMarker.minY + 7.13))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.62, y: destinationMarker.minY + 13.77), controlPoint1: CGPoint(x: destinationMarker.minX + 8.37, y: destinationMarker.minY + 7.28), controlPoint2: CGPoint(x: destinationMarker.minX + 5.75, y: destinationMarker.minY + 11.82))
        bezier2Path.addLine(to: CGPoint(x: destinationMarker.minX + 4.49, y: destinationMarker.minY + 14))
        bezier2Path.addLine(to: CGPoint(x: destinationMarker.minX + 4.38, y: destinationMarker.minY + 13.82))
        bezier2Path.close()
        bezier2Path.usesEvenOddFillRule = true
        fillColor.setFill()
        bezier2Path.fill()

        //// Bezier 3 Drawing
        let bezier3Path = UIBezierPath()
        bezier3Path.move(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 3.45))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 3.24, y: destinationMarker.minY + 4.8), controlPoint1: CGPoint(x: destinationMarker.minX + 3.8, y: destinationMarker.minY + 3.45), controlPoint2: CGPoint(x: destinationMarker.minX + 3.24, y: destinationMarker.minY + 4.06))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 6.15), controlPoint1: CGPoint(x: destinationMarker.minX + 3.24, y: destinationMarker.minY + 5.55), controlPoint2: CGPoint(x: destinationMarker.minX + 3.8, y: destinationMarker.minY + 6.15))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 5.76, y: destinationMarker.minY + 4.8), controlPoint1: CGPoint(x: destinationMarker.minX + 5.2, y: destinationMarker.minY + 6.15), controlPoint2: CGPoint(x: destinationMarker.minX + 5.76, y: destinationMarker.minY + 5.55))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 3.45), controlPoint1: CGPoint(x: destinationMarker.minX + 5.76, y: destinationMarker.minY + 4.06), controlPoint2: CGPoint(x: destinationMarker.minX + 5.2, y: destinationMarker.minY + 3.45))
        bezier3Path.addLine(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 3.45))
        bezier3Path.close()
        bezier3Path.move(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 6.73))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 2.7, y: destinationMarker.minY + 4.8), controlPoint1: CGPoint(x: destinationMarker.minX + 3.51, y: destinationMarker.minY + 6.73), controlPoint2: CGPoint(x: destinationMarker.minX + 2.7, y: destinationMarker.minY + 5.87))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 2.88), controlPoint1: CGPoint(x: destinationMarker.minX + 2.7, y: destinationMarker.minY + 3.74), controlPoint2: CGPoint(x: destinationMarker.minX + 3.51, y: destinationMarker.minY + 2.88))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 6.3, y: destinationMarker.minY + 4.8), controlPoint1: CGPoint(x: destinationMarker.minX + 5.49, y: destinationMarker.minY + 2.88), controlPoint2: CGPoint(x: destinationMarker.minX + 6.3, y: destinationMarker.minY + 3.74))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 6.73), controlPoint1: CGPoint(x: destinationMarker.minX + 6.3, y: destinationMarker.minY + 5.87), controlPoint2: CGPoint(x: destinationMarker.minX + 5.49, y: destinationMarker.minY + 6.73))
        bezier3Path.addLine(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 6.73))
        bezier3Path.close()
        bezier3Path.move(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 0.58))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 0.54, y: destinationMarker.minY + 4.82), controlPoint1: CGPoint(x: destinationMarker.minX + 2.32, y: destinationMarker.minY + 0.58), controlPoint2: CGPoint(x: destinationMarker.minX + 0.54, y: destinationMarker.minY + 2.48))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 0.93, y: destinationMarker.minY + 6.66), controlPoint1: CGPoint(x: destinationMarker.minX + 0.54, y: destinationMarker.minY + 5.44), controlPoint2: CGPoint(x: destinationMarker.minX + 0.66, y: destinationMarker.minY + 6.02))
        bezier3Path.addLine(to: CGPoint(x: destinationMarker.minX + 0.99, y: destinationMarker.minY + 6.78))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.46, y: destinationMarker.minY + 12.84), controlPoint1: CGPoint(x: destinationMarker.minX + 1.04, y: destinationMarker.minY + 6.88), controlPoint2: CGPoint(x: destinationMarker.minX + 2.77, y: destinationMarker.minY + 9.9))
        bezier3Path.addLine(to: CGPoint(x: destinationMarker.minX + 4.49, y: destinationMarker.minY + 12.9))
        bezier3Path.addLine(to: CGPoint(x: destinationMarker.minX + 4.53, y: destinationMarker.minY + 12.84))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 8.01, y: destinationMarker.minY + 6.78), controlPoint1: CGPoint(x: destinationMarker.minX + 6.22, y: destinationMarker.minY + 9.91), controlPoint2: CGPoint(x: destinationMarker.minX + 7.95, y: destinationMarker.minY + 6.9))
        bezier3Path.addLine(to: CGPoint(x: destinationMarker.minX + 8.07, y: destinationMarker.minY + 6.66))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 8.46, y: destinationMarker.minY + 4.82), controlPoint1: CGPoint(x: destinationMarker.minX + 8.34, y: destinationMarker.minY + 6.03), controlPoint2: CGPoint(x: destinationMarker.minX + 8.46, y: destinationMarker.minY + 5.44))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 0.58), controlPoint1: CGPoint(x: destinationMarker.minX + 8.46, y: destinationMarker.minY + 2.48), controlPoint2: CGPoint(x: destinationMarker.minX + 6.68, y: destinationMarker.minY + 0.58))
        bezier3Path.addLine(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 0.58))
        bezier3Path.close()
        bezier3Path.move(to: CGPoint(x: destinationMarker.minX + 4.38, y: destinationMarker.minY + 13.82))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 0.56, y: destinationMarker.minY + 7.13), controlPoint1: CGPoint(x: destinationMarker.minX + 4.23, y: destinationMarker.minY + 13.55), controlPoint2: CGPoint(x: destinationMarker.minX + 0.63, y: destinationMarker.minY + 7.27))
        bezier3Path.addLine(to: CGPoint(x: destinationMarker.minX + 0.44, y: destinationMarker.minY + 6.9))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX, y: destinationMarker.minY + 4.82), controlPoint1: CGPoint(x: destinationMarker.minX + 0.14, y: destinationMarker.minY + 6.19), controlPoint2: CGPoint(x: destinationMarker.minX, y: destinationMarker.minY + 5.52))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY), controlPoint1: CGPoint(x: destinationMarker.minX, y: destinationMarker.minY + 2.16), controlPoint2: CGPoint(x: destinationMarker.minX + 2.02, y: destinationMarker.minY))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 9, y: destinationMarker.minY + 4.82), controlPoint1: CGPoint(x: destinationMarker.minX + 6.98, y: destinationMarker.minY), controlPoint2: CGPoint(x: destinationMarker.minX + 9, y: destinationMarker.minY + 2.16))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 8.57, y: destinationMarker.minY + 6.88), controlPoint1: CGPoint(x: destinationMarker.minX + 9, y: destinationMarker.minY + 5.52), controlPoint2: CGPoint(x: destinationMarker.minX + 8.86, y: destinationMarker.minY + 6.17))
        bezier3Path.addLine(to: CGPoint(x: destinationMarker.minX + 8.45, y: destinationMarker.minY + 7.13))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.62, y: destinationMarker.minY + 13.77), controlPoint1: CGPoint(x: destinationMarker.minX + 8.37, y: destinationMarker.minY + 7.28), controlPoint2: CGPoint(x: destinationMarker.minX + 5.75, y: destinationMarker.minY + 11.82))
        bezier3Path.addLine(to: CGPoint(x: destinationMarker.minX + 4.49, y: destinationMarker.minY + 14))
        bezier3Path.addLine(to: CGPoint(x: destinationMarker.minX + 4.38, y: destinationMarker.minY + 13.82))
        bezier3Path.close()
        tripCanvasColor.setStroke()
        bezier3Path.lineWidth = 0.3
        bezier3Path.stroke()

        //// TripStart Drawing
        let tripStartPath = UIBezierPath(ovalIn: CGRect(x: frame.minX + 0.5, y: frame.minY + 1, width: 9, height: 9))
        tripCanvasColor.setStroke()
        tripStartPath.lineWidth = 1
        tripStartPath.stroke()

        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: frame.minX + 5, y: frame.minY + 9.92))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 5, y: frame.maxY - 15.99))
        tripCanvasColor.setStroke()
        bezierPath.lineWidth = 1
        context.saveGState()
        context.setLineDash(phase: 0, lengths: [2, 2])
        bezierPath.stroke()
        context.restoreGState()
    }

    @objc public dynamic class func drawBlueFavoriteIcon(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 22, height: 20), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 22, height: 20), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 22, y: resizedFrame.height / 20)

        //// Color Declarations
        let blueTextColor = UIColor(red: 0.078, green: 0.294, blue: 0.533, alpha: 1.000)

        //// favoriteTabbar.pdf Group
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 6.58, y: 1.51))
        bezierPath.addCurve(to: CGPoint(x: 2.78, y: 3.01), controlPoint1: CGPoint(x: 5.14, y: 1.51), controlPoint2: CGPoint(x: 3.79, y: 2.04))
        bezierPath.addCurve(to: CGPoint(x: 1.21, y: 6.61), controlPoint1: CGPoint(x: 1.76, y: 3.97), controlPoint2: CGPoint(x: 1.21, y: 5.25))
        bezierPath.addCurve(to: CGPoint(x: 2.78, y: 10.22), controlPoint1: CGPoint(x: 1.21, y: 7.98), controlPoint2: CGPoint(x: 1.76, y: 9.26))
        bezierPath.addLine(to: CGPoint(x: 11, y: 18.02))
        bezierPath.addLine(to: CGPoint(x: 19.22, y: 10.22))
        bezierPath.addCurve(to: CGPoint(x: 19.22, y: 3.01), controlPoint1: CGPoint(x: 21.32, y: 8.23), controlPoint2: CGPoint(x: 21.32, y: 4.99))
        bezierPath.addCurve(to: CGPoint(x: 15.42, y: 1.51), controlPoint1: CGPoint(x: 18.21, y: 2.04), controlPoint2: CGPoint(x: 16.86, y: 1.51))
        bezierPath.addCurve(to: CGPoint(x: 11.63, y: 3.01), controlPoint1: CGPoint(x: 13.99, y: 1.51), controlPoint2: CGPoint(x: 12.64, y: 2.04))
        bezierPath.addLine(to: CGPoint(x: 11, y: 3.6))
        bezierPath.addLine(to: CGPoint(x: 10.37, y: 3.01))
        bezierPath.addCurve(to: CGPoint(x: 6.58, y: 1.51), controlPoint1: CGPoint(x: 9.36, y: 2.04), controlPoint2: CGPoint(x: 8.01, y: 1.51))
        bezierPath.addLine(to: CGPoint(x: 6.58, y: 1.51))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: 1.95, y: 11))
        bezierPath.addCurve(to: CGPoint(x: 1.95, y: 2.22), controlPoint1: CGPoint(x: -0.6, y: 8.58), controlPoint2: CGPoint(x: -0.6, y: 4.64))
        bezierPath.addCurve(to: CGPoint(x: 6.58, y: 0.4), controlPoint1: CGPoint(x: 3.18, y: 1.05), controlPoint2: CGPoint(x: 4.83, y: 0.4))
        bezierPath.addCurve(to: CGPoint(x: 10.86, y: 1.92), controlPoint1: CGPoint(x: 8.15, y: 0.4), controlPoint2: CGPoint(x: 9.68, y: 0.94))
        bezierPath.addLine(to: CGPoint(x: 11, y: 2.03))
        bezierPath.addLine(to: CGPoint(x: 11.14, y: 1.92))
        bezierPath.addCurve(to: CGPoint(x: 15.42, y: 0.41), controlPoint1: CGPoint(x: 12.32, y: 0.94), controlPoint2: CGPoint(x: 13.85, y: 0.41))
        bezierPath.addCurve(to: CGPoint(x: 20.05, y: 2.22), controlPoint1: CGPoint(x: 17.17, y: 0.41), controlPoint2: CGPoint(x: 18.82, y: 1.05))
        bezierPath.addCurve(to: CGPoint(x: 20.05, y: 11), controlPoint1: CGPoint(x: 22.6, y: 4.64), controlPoint2: CGPoint(x: 22.6, y: 8.58))
        bezierPath.addLine(to: CGPoint(x: 11, y: 19.6))
        bezierPath.addLine(to: CGPoint(x: 1.95, y: 11))
        bezierPath.close()
        bezierPath.usesEvenOddFillRule = true
        blueTextColor.setFill()
        bezierPath.fill()
        blueTextColor.setStroke()
        bezierPath.lineWidth = 0
        bezierPath.stroke()

        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: 3.39, y: 6.49))
        bezier2Path.addCurve(to: CGPoint(x: 3.33, y: 6.49), controlPoint1: CGPoint(x: 3.37, y: 6.49), controlPoint2: CGPoint(x: 3.35, y: 6.49))
        bezier2Path.addCurve(to: CGPoint(x: 2.85, y: 5.75), controlPoint1: CGPoint(x: 3.07, y: 6.47), controlPoint2: CGPoint(x: 2.81, y: 6.37))
        bezier2Path.addCurve(to: CGPoint(x: 6.1, y: 2.69), controlPoint1: CGPoint(x: 2.95, y: 4.18), controlPoint2: CGPoint(x: 4.5, y: 2.72))
        bezier2Path.addCurve(to: CGPoint(x: 6.18, y: 2.69), controlPoint1: CGPoint(x: 6.13, y: 2.69), controlPoint2: CGPoint(x: 6.15, y: 2.69))
        bezier2Path.addCurve(to: CGPoint(x: 6.88, y: 3.15), controlPoint1: CGPoint(x: 6.66, y: 2.69), controlPoint2: CGPoint(x: 6.86, y: 2.83))
        bezier2Path.addCurve(to: CGPoint(x: 6.21, y: 3.67), controlPoint1: CGPoint(x: 6.9, y: 3.48), controlPoint2: CGPoint(x: 6.68, y: 3.58))
        bezier2Path.addCurve(to: CGPoint(x: 3.91, y: 5.88), controlPoint1: CGPoint(x: 4.77, y: 3.93), controlPoint2: CGPoint(x: 4.21, y: 4.46))
        bezier2Path.addCurve(to: CGPoint(x: 3.39, y: 6.49), controlPoint1: CGPoint(x: 3.81, y: 6.32), controlPoint2: CGPoint(x: 3.67, y: 6.49))
        bezier2Path.close()
        bezier2Path.usesEvenOddFillRule = true
        blueTextColor.setFill()
        bezier2Path.fill()
        blueTextColor.setStroke()
        bezier2Path.lineWidth = 0
        bezier2Path.stroke()

        context.restoreGState()
    }

    @objc public dynamic class func drawSaveButton(frame: CGRect = CGRect(x: 0, y: 0, width: 50, height: 25), enabled: Bool = false, buttonHighlighted: Bool = false) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Color Declarations
        let white = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let buttonHighlight = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 0.078)
        let buttonDefault = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.000)
        let editFavoriteBlue = UIColor(red: 0.133, green: 0.325, blue: 0.569, alpha: 1.000)

        //// Variable Declarations
        let opacity: CGFloat = enabled ? 1 : 0.3
        let buttonHighlightedColor = buttonHighlighted ? buttonHighlight : buttonDefault

        //// saveButtonTextRect Drawing
        context.saveGState()
        context.setAlpha(opacity)
        context.beginTransparencyLayer(auxiliaryInfo: nil)

        let saveButtonTextRectRect = CGRect(x: frame.minX + 1, y: frame.minY + 1, width: frame.width - 2, height: frame.height - 2)
        let saveButtonTextRectPath = UIBezierPath(roundedRect: saveButtonTextRectRect, cornerRadius: 4)
        editFavoriteBlue.setFill()
        saveButtonTextRectPath.fill()
        white.setStroke()
        saveButtonTextRectPath.lineWidth = 1
        saveButtonTextRectPath.stroke()
        let saveButtonTextRectTextContent = "Save"
        let saveButtonTextRectStyle = NSMutableParagraphStyle()
        saveButtonTextRectStyle.alignment = .center
        let saveButtonTextRectFontAttributes = [
            .font: UIFont.systemFont(ofSize: UIFont.systemFontSize, weight: UIFont.Weight.bold),
            .foregroundColor: white,
            .paragraphStyle: saveButtonTextRectStyle,
        ] as [NSAttributedStringKey: Any]

        let saveButtonTextRectTextHeight: CGFloat = saveButtonTextRectTextContent.boundingRect(with: CGSize(width: saveButtonTextRectRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: saveButtonTextRectFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: saveButtonTextRectRect)
        saveButtonTextRectTextContent.draw(in: CGRect(x: saveButtonTextRectRect.minX, y: saveButtonTextRectRect.minY + (saveButtonTextRectRect.height - saveButtonTextRectTextHeight) / 2, width: saveButtonTextRectRect.width, height: saveButtonTextRectTextHeight), withAttributes: saveButtonTextRectFontAttributes)
        context.restoreGState()

        context.endTransparencyLayer()
        context.restoreGState()

        //// SaveButtonShadow Drawing
        let saveButtonShadowPath = UIBezierPath(roundedRect: CGRect(x: frame.minX + 1, y: frame.minY + 1, width: frame.width - 2, height: frame.height - 2), cornerRadius: 4)
        buttonHighlightedColor.setFill()
        saveButtonShadowPath.fill()
    }

    @objc public dynamic class func drawDeleteFavorite(frame: CGRect = CGRect(x: 0, y: 0, width: 150, height: 25), enabled: Bool = false, buttonHighlighted: Bool = false) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Color Declarations
        let white = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let buttonHighlight = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 0.078)
        let buttonDefault = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.000)
        let editFavoriteBlue = UIColor(red: 0.133, green: 0.325, blue: 0.569, alpha: 1.000)

        //// Variable Declarations
        let opacity: CGFloat = enabled ? 1 : 0.3
        let buttonHighlightedColor = buttonHighlighted ? buttonHighlight : buttonDefault

        //// deleteButtonTextRect Drawing
        context.saveGState()
        context.setAlpha(opacity)
        context.beginTransparencyLayer(auxiliaryInfo: nil)

        let deleteButtonTextRectRect = CGRect(x: frame.minX + 1, y: frame.minY + 1, width: frame.width - 2, height: frame.height - 2)
        let deleteButtonTextRectPath = UIBezierPath(roundedRect: deleteButtonTextRectRect, cornerRadius: 4)
        editFavoriteBlue.setFill()
        deleteButtonTextRectPath.fill()
        UIColor.white.setStroke()
        deleteButtonTextRectPath.lineWidth = 1
        deleteButtonTextRectPath.stroke()
        let deleteButtonTextRectTextContent = "Delete Favorite"
        let deleteButtonTextRectStyle = NSMutableParagraphStyle()
        deleteButtonTextRectStyle.alignment = .center
        let deleteButtonTextRectFontAttributes = [
            .font: UIFont.systemFont(ofSize: UIFont.systemFontSize),
            .foregroundColor: white,
            .paragraphStyle: deleteButtonTextRectStyle,
        ] as [NSAttributedStringKey: Any]

        let deleteButtonTextRectTextHeight: CGFloat = deleteButtonTextRectTextContent.boundingRect(with: CGSize(width: deleteButtonTextRectRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: deleteButtonTextRectFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: deleteButtonTextRectRect)
        deleteButtonTextRectTextContent.draw(in: CGRect(x: deleteButtonTextRectRect.minX, y: deleteButtonTextRectRect.minY + (deleteButtonTextRectRect.height - deleteButtonTextRectTextHeight) / 2, width: deleteButtonTextRectRect.width, height: deleteButtonTextRectTextHeight), withAttributes: deleteButtonTextRectFontAttributes)
        context.restoreGState()

        context.endTransparencyLayer()
        context.restoreGState()

        //// SaveButtonShadow Drawing
        let saveButtonShadowPath = UIBezierPath(roundedRect: CGRect(x: frame.minX + 1, y: frame.minY + 1, width: frame.width - 2, height: frame.height - 2), cornerRadius: 4)
        buttonHighlightedColor.setFill()
        saveButtonShadowPath.fill()
    }

    @objc public dynamic class func drawMoreButton(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 43, height: 22), resizing: ResizingBehavior = .aspectFit, buttonHighlighted: Bool = false) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 43, height: 22), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 43, y: resizedFrame.height / 22)

        //// Color Declarations
        let buttonHighlight = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 0.078)
        let buttonDefault = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.000)
        let moreButtonBlack = UIColor(red: 0.184, green: 0.184, blue: 0.184, alpha: 1.000)

        //// Variable Declarations
        let buttonHighlightedColor = buttonHighlighted ? buttonHighlight : buttonDefault

        //// MoreButtonText Drawing
        let moreButtonTextRect = CGRect(x: 5, y: 0, width: 30.75, height: 22)
        let moreButtonTextTextContent = "MORE"
        let moreButtonTextStyle = NSMutableParagraphStyle()
        moreButtonTextStyle.alignment = .left
        let moreButtonTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: 10),
            .foregroundColor: moreButtonBlack,
            .paragraphStyle: moreButtonTextStyle,
        ] as [NSAttributedStringKey: Any]

        let moreButtonTextTextHeight: CGFloat = moreButtonTextTextContent.boundingRect(with: CGSize(width: moreButtonTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: moreButtonTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: moreButtonTextRect)
        moreButtonTextTextContent.draw(in: CGRect(x: moreButtonTextRect.minX, y: moreButtonTextRect.minY + (moreButtonTextRect.height - moreButtonTextTextHeight) / 2, width: moreButtonTextRect.width, height: moreButtonTextTextHeight), withAttributes: moreButtonTextFontAttributes)
        context.restoreGState()

        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 39.5, y: 8.5))
        bezierPath.addLine(to: CGPoint(x: 42.46, y: 11.46))
        bezierPath.addLine(to: CGPoint(x: 39.5, y: 14.42))
        moreButtonBlack.setStroke()
        bezierPath.lineWidth = 1
        bezierPath.stroke()

        //// Rectangle Drawing
        let rectanglePath = UIBezierPath(rect: CGRect(x: 0, y: 0, width: 43, height: 22))
        buttonHighlightedColor.setFill()
        rectanglePath.fill()

        context.restoreGState()
    }

    @objc public dynamic class func drawAlertView(alertViewFrame: CGRect = CGRect(x: 0, y: 0, width: 100, height: 100)) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Color Declarations
        let alertBurntOrange1 = UIColor(red: 0.800, green: 0.320, blue: 0.320, alpha: 1.000)
        let alertBurntOrange2 = UIColor(red: 0.851, green: 0.388, blue: 0.251, alpha: 1.000)
        let alertBurntOrange3 = UIColor(red: 0.914, green: 0.541, blue: 0.427, alpha: 1.000)
        let alertBurntOrange4 = UIColor(red: 0.961, green: 0.694, blue: 0.612, alpha: 1.000)
        let alertBurntOrange5 = UIColor(red: 0.988, green: 0.847, blue: 0.800, alpha: 1.000)

        //// Gradient Declarations
        let alertOrange = CGGradient(colorsSpace: nil, colors: [alertBurntOrange1.cgColor, alertBurntOrange2.cgColor, alertBurntOrange3.cgColor, alertBurntOrange4.cgColor, alertBurntOrange5.cgColor, UIColor.white.cgColor] as CFArray, locations: [0, 0.2, 0.4, 0.6, 0.76, 1])!

        //// Rectangle Drawing
        context.saveGState()
        context.setAlpha(0.2)

        let rectangleRect = CGRect(x: alertViewFrame.minX, y: alertViewFrame.minY, width: alertViewFrame.width, height: alertViewFrame.height)
        let rectanglePath = UIBezierPath(rect: rectangleRect)
        context.saveGState()
        rectanglePath.addClip()
        context.drawLinearGradient(alertOrange,
                                   start: CGPoint(x: rectangleRect.maxX, y: rectangleRect.midY),
                                   end: CGPoint(x: rectangleRect.minX, y: rectangleRect.midY),
                                   options: [])
        context.restoreGState()

        context.restoreGState()
    }

    @objc public dynamic class func drawReverseTripButton(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 60, height: 25), resizing: ResizingBehavior = .aspectFit, buttonHighlighted: Bool = false) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 60, height: 25), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 60, y: resizedFrame.height / 25)

        //// Color Declarations
        let fillColor = UIColor(red: 0.078, green: 0.294, blue: 0.533, alpha: 1.000)
        let blueTextColor = UIColor(red: 0.078, green: 0.294, blue: 0.533, alpha: 1.000)
        let strokeColor = UIColor(red: 0.078, green: 0.294, blue: 0.533, alpha: 1.000)
        let buttonHighlight = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 0.078)
        let buttonDefault = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.000)

        //// Variable Declarations
        let buttonHighlightedColor = buttonHighlighted ? buttonHighlight : buttonDefault

        //// background Drawing
        let backgroundPath = UIBezierPath(roundedRect: CGRect(x: 0.08, y: 0, width: 63.39, height: 23.81), cornerRadius: 3)
        buttonHighlightedColor.setFill()
        backgroundPath.fill()

        //// nextToArriveLabel Drawing
        let nextToArriveLabelRect = CGRect(x: 0, y: -0.15, width: 38.75, height: 23.35)
        let nextToArriveLabelTextContent = "Reverse Trip"
        let nextToArriveLabelStyle = NSMutableParagraphStyle()
        nextToArriveLabelStyle.alignment = .right
        let nextToArriveLabelFontAttributes = [
            .font: UIFont.systemFont(ofSize: 10),
            .foregroundColor: blueTextColor,
            .paragraphStyle: nextToArriveLabelStyle,
        ] as [NSAttributedStringKey: Any]

        let nextToArriveLabelTextHeight: CGFloat = nextToArriveLabelTextContent.boundingRect(with: CGSize(width: nextToArriveLabelRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: nextToArriveLabelFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: nextToArriveLabelRect)
        nextToArriveLabelTextContent.draw(in: CGRect(x: nextToArriveLabelRect.minX, y: nextToArriveLabelRect.minY + (nextToArriveLabelRect.height - nextToArriveLabelTextHeight) / 2, width: nextToArriveLabelRect.width, height: nextToArriveLabelTextHeight), withAttributes: nextToArriveLabelFontAttributes)
        context.restoreGState()

        //// Bezier 9 Drawing
        let bezier9Path = UIBezierPath()
        UIColor.black.setStroke()
        bezier9Path.lineWidth = 1
        bezier9Path.stroke()

        //// reverseIcon.pdf Group
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 54.03, y: 3.75))
        bezierPath.addLine(to: CGPoint(x: 54.03, y: 21.75))
        bezierPath.addLine(to: CGPoint(x: 59.03, y: 17.71))
        bezierPath.addLine(to: CGPoint(x: 58.5, y: 16.95))
        bezierPath.addLine(to: CGPoint(x: 54.97, y: 19.8))
        bezierPath.addLine(to: CGPoint(x: 54.97, y: 3.75))
        bezierPath.addLine(to: CGPoint(x: 54.03, y: 3.75))
        bezierPath.close()
        bezierPath.usesEvenOddFillRule = true
        fillColor.setFill()
        bezierPath.fill()

        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: 54.03, y: 3.75))
        bezier2Path.addLine(to: CGPoint(x: 54.03, y: 21.75))
        bezier2Path.addLine(to: CGPoint(x: 59.03, y: 17.71))
        bezier2Path.addLine(to: CGPoint(x: 58.5, y: 16.95))
        bezier2Path.addLine(to: CGPoint(x: 54.97, y: 19.8))
        bezier2Path.addLine(to: CGPoint(x: 54.97, y: 3.75))
        bezier2Path.addLine(to: CGPoint(x: 54.03, y: 3.75))
        bezier2Path.close()
        strokeColor.setStroke()
        bezier2Path.lineWidth = 0.5
        bezier2Path.stroke()

        //// Bezier 3 Drawing
        let bezier3Path = UIBezierPath()
        bezier3Path.move(to: CGPoint(x: 45.03, y: 7.8))
        bezier3Path.addLine(to: CGPoint(x: 45.55, y: 8.57))
        bezier3Path.addLine(to: CGPoint(x: 49.1, y: 5.71))
        bezier3Path.addLine(to: CGPoint(x: 49.1, y: 21.75))
        bezier3Path.addLine(to: CGPoint(x: 50.03, y: 21.75))
        bezier3Path.addLine(to: CGPoint(x: 50.03, y: 3.75))
        bezier3Path.addLine(to: CGPoint(x: 45.03, y: 7.8))
        bezier3Path.close()
        bezier3Path.usesEvenOddFillRule = true
        fillColor.setFill()
        bezier3Path.fill()

        //// Bezier 4 Drawing
        let bezier4Path = UIBezierPath()
        bezier4Path.move(to: CGPoint(x: 45.03, y: 7.8))
        bezier4Path.addLine(to: CGPoint(x: 45.55, y: 8.57))
        bezier4Path.addLine(to: CGPoint(x: 49.1, y: 5.71))
        bezier4Path.addLine(to: CGPoint(x: 49.1, y: 21.75))
        bezier4Path.addLine(to: CGPoint(x: 50.03, y: 21.75))
        bezier4Path.addLine(to: CGPoint(x: 50.03, y: 3.75))
        bezier4Path.addLine(to: CGPoint(x: 45.03, y: 7.8))
        bezier4Path.close()
        strokeColor.setStroke()
        bezier4Path.lineWidth = 0.5
        bezier4Path.stroke()

        context.restoreGState()
    }

    @objc public dynamic class func drawNextToArriveButton(buttonFrame: CGRect = CGRect(x: 0, y: -0, width: 250, height: 100), buttonHighlighted: Bool = false) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }

        //// Color Declarations
        let redButtonGradientLeft = UIColor(red: 0.502, green: 0.153, blue: 0.063, alpha: 1.000)
        let redButtonGradientRight1 = UIColor(red: 0.843, green: 0.227, blue: 0.071, alpha: 1.000)
        let fillColor2 = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let buttonHighlight = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 0.078)
        let buttonDefault = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.000)
        let buttonShadowColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 0.075)

        //// Gradient Declarations
        let redButtonGradient = CGGradient(colorsSpace: nil, colors: [redButtonGradientLeft.cgColor, redButtonGradientRight1.cgColor] as CFArray, locations: [0, 1])!

        //// Shadow Declarations
        let buttonShadow = NSShadow()
        buttonShadow.shadowColor = buttonShadowColor
        buttonShadow.shadowOffset = CGSize(width: 0, height: 0)
        buttonShadow.shadowBlurRadius = 3

        //// Variable Declarations
        let buttonHighlightedColor = buttonHighlighted ? buttonHighlight : buttonDefault

        //// Subframes
        let frame = CGRect(x: buttonFrame.minX + fastFloor((buttonFrame.width - 224.13) * 0.55446 + 0.15) + 0.35, y: buttonFrame.minY + fastFloor((buttonFrame.height - 50) * 0.50000 - 0.5) + 1, width: 224.13, height: 50)

        //// Rectangle Drawing
        let rectangleRect = CGRect(x: buttonFrame.minX + 3, y: buttonFrame.minY + fastFloor((buttonFrame.height - 3) * 0.03093 - 0.5) + 1, width: buttonFrame.width - 6, height: buttonFrame.height - 4 - fastFloor((buttonFrame.height - 3) * 0.03093 - 0.5))
        let rectanglePath = UIBezierPath(roundedRect: rectangleRect, cornerRadius: 4)
        context.saveGState()
        context.setShadow(offset: buttonShadow.shadowOffset, blur: buttonShadow.shadowBlurRadius, color: (buttonShadow.shadowColor as! UIColor).cgColor)
        context.beginTransparencyLayer(auxiliaryInfo: nil)
        rectanglePath.addClip()
        context.drawLinearGradient(redButtonGradient,
                                   start: CGPoint(x: rectangleRect.minX, y: rectangleRect.midY),
                                   end: CGPoint(x: rectangleRect.maxX, y: rectangleRect.midY),
                                   options: [])
        context.endTransparencyLayer()
        context.restoreGState()

        //// Text Drawing
        let textRect = CGRect(x: frame.minX + 33.16, y: frame.minY + 9.5, width: 190.97, height: 28.46)
        let textTextContent = "Next to Arrive for this Route"
        let textStyle = NSMutableParagraphStyle()
        textStyle.alignment = .left
        let textFontAttributes = [
            .font: UIFont.boldSystemFont(ofSize: UIFont.systemFontSize),
            .foregroundColor: UIColor.white,
            .paragraphStyle: textStyle,
        ] as [NSAttributedStringKey: Any]

        let textTextHeight: CGFloat = textTextContent.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textRect)
        textTextContent.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
        context.restoreGState()

        //// Group
        //// Icon
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: frame.minX + 15.34, y: frame.minY + 32.38))
        bezierPath.addCurve(to: CGPoint(x: frame.minX + 6.39, y: frame.minY + 23.69), controlPoint1: CGPoint(x: frame.minX + 10.4, y: frame.minY + 32.38), controlPoint2: CGPoint(x: frame.minX + 6.39, y: frame.minY + 28.48))
        bezierPath.addCurve(to: CGPoint(x: frame.minX + 15.34, y: frame.minY + 14.99), controlPoint1: CGPoint(x: frame.minX + 6.39, y: frame.minY + 18.89), controlPoint2: CGPoint(x: frame.minX + 10.4, y: frame.minY + 14.99))
        bezierPath.addCurve(to: CGPoint(x: frame.minX + 24.29, y: frame.minY + 23.69), controlPoint1: CGPoint(x: frame.minX + 20.27, y: frame.minY + 14.99), controlPoint2: CGPoint(x: frame.minX + 24.29, y: frame.minY + 18.89))
        bezierPath.addCurve(to: CGPoint(x: frame.minX + 15.34, y: frame.minY + 32.38), controlPoint1: CGPoint(x: frame.minX + 24.29, y: frame.minY + 28.48), controlPoint2: CGPoint(x: frame.minX + 20.27, y: frame.minY + 32.38))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: frame.minX + 15.44, y: frame.minY + 25.43))
        bezierPath.addCurve(to: CGPoint(x: frame.minX + 17.33, y: frame.minY + 23.57), controlPoint1: CGPoint(x: frame.minX + 16.48, y: frame.minY + 25.43), controlPoint2: CGPoint(x: frame.minX + 17.33, y: frame.minY + 24.59))
        bezierPath.addCurve(to: CGPoint(x: frame.minX + 17.18, y: frame.minY + 22.87), controlPoint1: CGPoint(x: frame.minX + 17.33, y: frame.minY + 23.33), controlPoint2: CGPoint(x: frame.minX + 17.28, y: frame.minY + 23.1))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 19.62, y: frame.minY + 20.47))
        bezierPath.addCurve(to: CGPoint(x: frame.minX + 19.62, y: frame.minY + 19.53), controlPoint1: CGPoint(x: frame.minX + 19.88, y: frame.minY + 20.21), controlPoint2: CGPoint(x: frame.minX + 19.88, y: frame.minY + 19.79))
        bezierPath.addCurve(to: CGPoint(x: frame.minX + 19.14, y: frame.minY + 19.34), controlPoint1: CGPoint(x: frame.minX + 19.49, y: frame.minY + 19.41), controlPoint2: CGPoint(x: frame.minX + 19.32, y: frame.minY + 19.34))
        bezierPath.addCurve(to: CGPoint(x: frame.minX + 18.66, y: frame.minY + 19.53), controlPoint1: CGPoint(x: frame.minX + 18.96, y: frame.minY + 19.34), controlPoint2: CGPoint(x: frame.minX + 18.79, y: frame.minY + 19.41))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 16.26, y: frame.minY + 21.9))
        bezierPath.addCurve(to: CGPoint(x: frame.minX + 15.44, y: frame.minY + 21.71), controlPoint1: CGPoint(x: frame.minX + 16, y: frame.minY + 21.77), controlPoint2: CGPoint(x: frame.minX + 15.72, y: frame.minY + 21.71))
        bezierPath.addCurve(to: CGPoint(x: frame.minX + 13.55, y: frame.minY + 23.57), controlPoint1: CGPoint(x: frame.minX + 14.4, y: frame.minY + 21.71), controlPoint2: CGPoint(x: frame.minX + 13.55, y: frame.minY + 22.54))
        bezierPath.addCurve(to: CGPoint(x: frame.minX + 15.44, y: frame.minY + 25.43), controlPoint1: CGPoint(x: frame.minX + 13.55, y: frame.minY + 24.59), controlPoint2: CGPoint(x: frame.minX + 14.4, y: frame.minY + 25.43))
        bezierPath.close()
        bezierPath.usesEvenOddFillRule = true
        fillColor2.setFill()
        bezierPath.fill()

        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: frame.minX + 14.33, y: frame.minY + 15.03))
        bezier2Path.addCurve(to: CGPoint(x: frame.minX + 13.85, y: frame.minY + 14.51), controlPoint1: CGPoint(x: frame.minX + 14.06, y: frame.minY + 15.03), controlPoint2: CGPoint(x: frame.minX + 13.85, y: frame.minY + 14.8))
        bezier2Path.addLine(to: CGPoint(x: frame.minX + 13.85, y: frame.minY + 14.18))
        bezier2Path.addCurve(to: CGPoint(x: frame.minX + 14.68, y: frame.minY + 13.29), controlPoint1: CGPoint(x: frame.minX + 13.85, y: frame.minY + 13.69), controlPoint2: CGPoint(x: frame.minX + 14.22, y: frame.minY + 13.29))
        bezier2Path.addLine(to: CGPoint(x: frame.minX + 16.59, y: frame.minY + 13.29))
        bezier2Path.addCurve(to: CGPoint(x: frame.minX + 17.43, y: frame.minY + 14.18), controlPoint1: CGPoint(x: frame.minX + 17.05, y: frame.minY + 13.29), controlPoint2: CGPoint(x: frame.minX + 17.43, y: frame.minY + 13.69))
        bezier2Path.addLine(to: CGPoint(x: frame.minX + 17.43, y: frame.minY + 14.51))
        bezier2Path.addCurve(to: CGPoint(x: frame.minX + 16.94, y: frame.minY + 15.03), controlPoint1: CGPoint(x: frame.minX + 17.43, y: frame.minY + 14.8), controlPoint2: CGPoint(x: frame.minX + 17.21, y: frame.minY + 15.03))
        bezier2Path.addLine(to: CGPoint(x: frame.minX + 14.33, y: frame.minY + 15.03))
        bezier2Path.close()
        bezier2Path.usesEvenOddFillRule = true
        fillColor2.setFill()
        bezier2Path.fill()

        //// Bezier 3 Drawing
        let bezier3Path = UIBezierPath()
        bezier3Path.move(to: CGPoint(x: frame.minX + 1, y: frame.minY + 24.16))
        bezier3Path.addCurve(to: CGPoint(x: frame.minX + 0.45, y: frame.minY + 23.73), controlPoint1: CGPoint(x: frame.minX + 0.7, y: frame.minY + 24.16), controlPoint2: CGPoint(x: frame.minX + 0.45, y: frame.minY + 23.97))
        bezier3Path.addCurve(to: CGPoint(x: frame.minX + 1, y: frame.minY + 23.29), controlPoint1: CGPoint(x: frame.minX + 0.45, y: frame.minY + 23.49), controlPoint2: CGPoint(x: frame.minX + 0.7, y: frame.minY + 23.29))
        bezier3Path.addLine(to: CGPoint(x: frame.minX + 5.28, y: frame.minY + 23.29))
        bezier3Path.addCurve(to: CGPoint(x: frame.minX + 5.82, y: frame.minY + 23.73), controlPoint1: CGPoint(x: frame.minX + 5.58, y: frame.minY + 23.29), controlPoint2: CGPoint(x: frame.minX + 5.82, y: frame.minY + 23.49))
        bezier3Path.addCurve(to: CGPoint(x: frame.minX + 5.28, y: frame.minY + 24.16), controlPoint1: CGPoint(x: frame.minX + 5.82, y: frame.minY + 23.97), controlPoint2: CGPoint(x: frame.minX + 5.58, y: frame.minY + 24.16))
        bezier3Path.addLine(to: CGPoint(x: frame.minX + 1, y: frame.minY + 24.16))
        bezier3Path.close()
        bezier3Path.usesEvenOddFillRule = true
        fillColor2.setFill()
        bezier3Path.fill()

        //// Bezier 4 Drawing
        let bezier4Path = UIBezierPath()
        bezier4Path.move(to: CGPoint(x: frame.minX + 1.92, y: frame.minY + 27.8))
        bezier4Path.addCurve(to: CGPoint(x: frame.minX + 1.35, y: frame.minY + 27.36), controlPoint1: CGPoint(x: frame.minX + 1.6, y: frame.minY + 27.8), controlPoint2: CGPoint(x: frame.minX + 1.35, y: frame.minY + 27.6))
        bezier4Path.addCurve(to: CGPoint(x: frame.minX + 1.92, y: frame.minY + 26.93), controlPoint1: CGPoint(x: frame.minX + 1.35, y: frame.minY + 27.12), controlPoint2: CGPoint(x: frame.minX + 1.6, y: frame.minY + 26.93))
        bezier4Path.addLine(to: CGPoint(x: frame.minX + 5.24, y: frame.minY + 26.93))
        bezier4Path.addCurve(to: CGPoint(x: frame.minX + 5.82, y: frame.minY + 27.36), controlPoint1: CGPoint(x: frame.minX + 5.56, y: frame.minY + 26.93), controlPoint2: CGPoint(x: frame.minX + 5.82, y: frame.minY + 27.12))
        bezier4Path.addCurve(to: CGPoint(x: frame.minX + 5.24, y: frame.minY + 27.8), controlPoint1: CGPoint(x: frame.minX + 5.82, y: frame.minY + 27.6), controlPoint2: CGPoint(x: frame.minX + 5.56, y: frame.minY + 27.8))
        bezier4Path.addLine(to: CGPoint(x: frame.minX + 1.92, y: frame.minY + 27.8))
        bezier4Path.close()
        bezier4Path.usesEvenOddFillRule = true
        fillColor2.setFill()
        bezier4Path.fill()

        //// Bezier 5 Drawing
        let bezier5Path = UIBezierPath()
        bezier5Path.move(to: CGPoint(x: frame.minX + 1.92, y: frame.minY + 21.43))
        bezier5Path.addCurve(to: CGPoint(x: frame.minX + 1.35, y: frame.minY + 21), controlPoint1: CGPoint(x: frame.minX + 1.6, y: frame.minY + 21.43), controlPoint2: CGPoint(x: frame.minX + 1.35, y: frame.minY + 21.24))
        bezier5Path.addCurve(to: CGPoint(x: frame.minX + 1.92, y: frame.minY + 20.56), controlPoint1: CGPoint(x: frame.minX + 1.35, y: frame.minY + 20.76), controlPoint2: CGPoint(x: frame.minX + 1.6, y: frame.minY + 20.56))
        bezier5Path.addLine(to: CGPoint(x: frame.minX + 5.24, y: frame.minY + 20.56))
        bezier5Path.addCurve(to: CGPoint(x: frame.minX + 5.82, y: frame.minY + 21), controlPoint1: CGPoint(x: frame.minX + 5.56, y: frame.minY + 20.56), controlPoint2: CGPoint(x: frame.minX + 5.82, y: frame.minY + 20.76))
        bezier5Path.addCurve(to: CGPoint(x: frame.minX + 5.24, y: frame.minY + 21.43), controlPoint1: CGPoint(x: frame.minX + 5.82, y: frame.minY + 21.24), controlPoint2: CGPoint(x: frame.minX + 5.56, y: frame.minY + 21.43))
        bezier5Path.addLine(to: CGPoint(x: frame.minX + 1.92, y: frame.minY + 21.43))
        bezier5Path.close()
        bezier5Path.usesEvenOddFillRule = true
        fillColor2.setFill()
        bezier5Path.fill()

        //// NextToArriveButtonIcon.pdf Group

        //// Shadow Drawing
        let shadowPath = UIBezierPath(roundedRect: CGRect(x: buttonFrame.minX + fastFloor((buttonFrame.width - 3) * 0.01215 + 0.5), y: buttonFrame.minY + fastFloor((buttonFrame.height - 3) * 0.03093 - 0.5) + 1, width: buttonFrame.width - 3 - fastFloor((buttonFrame.width - 3) * 0.01215 + 0.5), height: buttonFrame.height - 4 - fastFloor((buttonFrame.height - 3) * 0.03093 - 0.5)), cornerRadius: 4)
        context.saveGState()
        context.setShadow(offset: buttonShadow.shadowOffset, blur: buttonShadow.shadowBlurRadius, color: (buttonShadow.shadowColor as! UIColor).cgColor)
        buttonHighlightedColor.setFill()
        shadowPath.fill()
        context.restoreGState()
    }

    @objc public dynamic class func drawConnectingDiamondStationView(frame: CGRect = CGRect(x: 0, y: 0, width: 10, height: 10)) {
        //// Color Declarations
        let tripCanvasColor = UIColor(red: 0.078, green: 0.294, blue: 0.533, alpha: 1.000)

        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: frame.minX + 1, y: frame.minY + 0.50000 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.50000 * frame.width, y: frame.maxY - 1))
        bezierPath.addLine(to: CGPoint(x: frame.maxX - 1, y: frame.minY + 0.50000 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.50000 * frame.width, y: frame.minY + 1))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 1, y: frame.minY + 0.50000 * frame.height))
        bezierPath.close()
        tripCanvasColor.setFill()
        bezierPath.fill()
        tripCanvasColor.setStroke()
        bezierPath.lineWidth = 1
        bezierPath.lineCapStyle = .square
        bezierPath.stroke()
    }

    @objc public dynamic class func drawConnectingGradientView(frame: CGRect = CGRect(x: 0, y: 0, width: 15, height: 3)) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Color Declarations
        let connectingGradientLeft = UIColor(red: 0.906, green: 0.949, blue: 0.996, alpha: 1.000)
        let connectingGradientMid = UIColor(red: 0.898, green: 0.945, blue: 0.992, alpha: 1.000)

        //// Gradient Declarations
        let connectingGradient = CGGradient(colorsSpace: nil, colors: [connectingGradientLeft.cgColor, connectingGradientMid.cgColor, UIColor.white.cgColor] as CFArray, locations: [0, 0.48, 1])!

        //// Rectangle Drawing
        let rectangleRect = CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: frame.height)
        let rectanglePath = UIBezierPath(rect: rectangleRect)
        context.saveGState()
        rectanglePath.addClip()
        context.drawLinearGradient(connectingGradient,
                                   start: CGPoint(x: rectangleRect.minX, y: rectangleRect.midY),
                                   end: CGPoint(x: rectangleRect.maxX, y: rectangleRect.midY),
                                   options: [])
        context.restoreGState()
    }

    @objc public dynamic class func drawConnectingFlatDividerView(frame: CGRect = CGRect(x: 0, y: 0, width: 20, height: 1)) {
        //// Color Declarations
        let connectingDividerColor = UIColor(red: 0.855, green: 0.855, blue: 0.855, alpha: 1.000)

        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: frame.minX, y: frame.minY + 0.5))
        bezierPath.addLine(to: CGPoint(x: frame.maxX, y: frame.minY + 0.5))
        connectingDividerColor.setStroke()
        bezierPath.lineWidth = 1
        bezierPath.stroke()
    }

    @objc public dynamic class func drawConnectingBentDividerViewLeft(frame: CGRect = CGRect(x: 0, y: 0, width: 11, height: 11)) {
        //// Color Declarations
        let connectingDividerColor = UIColor(red: 0.855, green: 0.855, blue: 0.855, alpha: 1.000)

        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: frame.minX + 0.5, y: frame.minY + 11))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.5, y: frame.minY + 0.5))
        bezierPath.addLine(to: CGPoint(x: frame.maxX, y: frame.minY + 0.5))
        connectingDividerColor.setStroke()
        bezierPath.lineWidth = 1
        bezierPath.stroke()
    }

    @objc public dynamic class func drawConnectingBentDividerViewRight(frame: CGRect = CGRect(x: 0, y: 0, width: 11, height: 11)) {
        //// Color Declarations
        let connectingDividerColor = UIColor(red: 0.855, green: 0.855, blue: 0.855, alpha: 1.000)

        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: frame.maxX - 0.5, y: frame.minY + 11))
        bezierPath.addLine(to: CGPoint(x: frame.maxX - 0.5, y: frame.minY + 0.5))
        bezierPath.addLine(to: CGPoint(x: frame.minX, y: frame.minY + 0.5))
        connectingDividerColor.setStroke()
        bezierPath.lineWidth = 1
        bezierPath.stroke()
    }

    @objc(SeptaDrawResizingBehavior)
    public enum ResizingBehavior: Int {
        case aspectFit /// The content is proportionally resized to fit into the target rectangle.
        case aspectFill /// The content is proportionally resized to completely fill the target rectangle.
        case stretch /// The content is stretched to match the entire target rectangle.
        case center /// The content is centered in the target rectangle, but it is NOT resized.

        public func apply(rect: CGRect, target: CGRect) -> CGRect {
            if rect == target || target == CGRect.zero {
                return rect
            }

            var scales = CGSize.zero
            scales.width = abs(target.width / rect.width)
            scales.height = abs(target.height / rect.height)

            switch self {
            case .aspectFit:
                scales.width = min(scales.width, scales.height)
                scales.height = scales.width
            case .aspectFill:
                scales.width = max(scales.width, scales.height)
                scales.height = scales.width
            case .stretch:
                break
            case .center:
                scales.width = 1
                scales.height = 1
            }

            var result = rect.standardized
            result.size.width *= scales.width
            result.size.height *= scales.height
            result.origin.x = target.minX + (target.width - result.width) / 2
            result.origin.y = target.minY + (target.height - result.height) / 2
            return result
        }
    }
}

private extension UIColor {
    func blended(withFraction fraction: CGFloat, of color: UIColor) -> UIColor {
        var r1: CGFloat = 1, g1: CGFloat = 1, b1: CGFloat = 1, a1: CGFloat = 1
        var r2: CGFloat = 1, g2: CGFloat = 1, b2: CGFloat = 1, a2: CGFloat = 1

        getRed(&r1, green: &g1, blue: &b1, alpha: &a1)
        color.getRed(&r2, green: &g2, blue: &b2, alpha: &a2)

        return UIColor(red: r1 * (1 - fraction) + r2 * fraction,
                       green: g1 * (1 - fraction) + g2 * fraction,
                       blue: b1 * (1 - fraction) + b2 * fraction,
                       alpha: a1 * (1 - fraction) + a2 * fraction)
    }
}
