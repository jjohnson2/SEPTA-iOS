//
//  SeptaDraw.swift
//  Septa
//
//  Created by Mark Broski on 9/2/17.
//  Copyright Â© 2017 SEPTA. All rights reserved.
//
//  Generated by PaintCode
//  http://www.paintcodeapp.com
//

import UIKit

public class SeptaDraw: NSObject {

    //// Drawing Methods

    @objc public dynamic class func drawBlueGradientView(frame: CGRect = CGRect(x: 17, y: 49, width: 106, height: 59)) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Color Declarations
        let blueGradientTop = UIColor(red: 0.788, green: 0.890, blue: 1.000, alpha: 1.000)
        let blueGradientBottom = UIColor(red: 0.976, green: 0.988, blue: 1.000, alpha: 1.000)

        //// Gradient Declarations
        let blueGradient = CGGradient(colorsSpace: nil, colors: [blueGradientTop.cgColor, blueGradientBottom.cgColor] as CFArray, locations: [0, 1])!

        //// View Drawing
        let viewRect = CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: frame.height)
        let viewPath = UIBezierPath(rect: viewRect)
        context.saveGState()
        viewPath.addClip()
        context.drawLinearGradient(blueGradient,
                                   start: CGPoint(x: viewRect.midX, y: viewRect.minY),
                                   end: CGPoint(x: viewRect.midX, y: viewRect.maxY),
                                   options: [])
        context.restoreGState()
    }

    @objc public dynamic class func drawBlueGradientCell(frame: CGRect = CGRect(x: 0, y: 0, width: 76, height: 32), shouldFill: Bool = true, enabled: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Color Declarations
        let blueGradientLeft = UIColor(red: 0.871, green: 0.933, blue: 1.000, alpha: 1.000)
        let blueGradientRight = UIColor(red: 0.976, green: 0.988, blue: 1.000, alpha: 1.000)
        let cellBorder = UIColor(red: 0.514, green: 0.635, blue: 0.765, alpha: 1.000)
        let white = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)

        //// Gradient Declarations
        let blueGradientLeftToRight = CGGradient(colorsSpace: nil, colors: [blueGradientLeft.cgColor, blueGradientLeft.blended(withFraction: 0.5, of: blueGradientRight).cgColor, blueGradientRight.cgColor] as CFArray, locations: [0, 0.24, 1])!
        let whiteGradient = CGGradient(colorsSpace: nil, colors: [white.cgColor, UIColor.white.cgColor] as CFArray, locations: [0, 1])!

        //// Shadow Declarations
        let cellShadow = NSShadow()
        cellShadow.shadowColor = UIColor.black.withAlphaComponent(0.14)
        cellShadow.shadowOffset = CGSize(width: 0, height: 0)
        cellShadow.shadowBlurRadius = 2

        //// Variable Declarations
        let cellFill = shouldFill ? blueGradientLeftToRight : whiteGradient
        let opacity: CGFloat = enabled ? 1 : 0.3

        //// Rectangle Drawing
        context.saveGState()
        context.setAlpha(opacity)
        context.beginTransparencyLayer(auxiliaryInfo: nil)

        let rectangleRect = CGRect(x: frame.minX + 0.5, y: frame.minY + 0.5, width: frame.width - 1, height: frame.height - 1)
        let rectanglePath = UIBezierPath(roundedRect: rectangleRect, cornerRadius: 4)
        context.saveGState()
        context.setShadow(offset: cellShadow.shadowOffset, blur: cellShadow.shadowBlurRadius, color: (cellShadow.shadowColor as! UIColor).cgColor)
        context.beginTransparencyLayer(auxiliaryInfo: nil)
        rectanglePath.addClip()
        context.drawLinearGradient(cellFill,
                                   start: CGPoint(x: rectangleRect.maxX, y: rectangleRect.midY),
                                   end: CGPoint(x: rectangleRect.minX, y: rectangleRect.midY),
                                   options: [])
        context.endTransparencyLayer()
        context.restoreGState()

        cellBorder.setStroke()
        rectanglePath.lineWidth = 1
        rectanglePath.lineJoinStyle = .round
        rectanglePath.stroke()

        context.endTransparencyLayer()
        context.restoreGState()
    }

    @objc public dynamic class func drawRedButton(frame: CGRect = CGRect(x: 0, y: 0, width: 125, height: 46), redButtonText: String = "Button Text", enabled: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Color Declarations
        let white = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let redButtonGradientLeft = UIColor(red: 0.502, green: 0.153, blue: 0.063, alpha: 1.000)
        let redButtonGradientRight1 = UIColor(red: 0.843, green: 0.227, blue: 0.071, alpha: 1.000)

        //// Gradient Declarations
        let redButtonGradient = CGGradient(colorsSpace: nil, colors: [redButtonGradientLeft.cgColor, redButtonGradientRight1.cgColor] as CFArray, locations: [0, 1])!

        //// Shadow Declarations
        let cellShadow = NSShadow()
        cellShadow.shadowColor = UIColor.black.withAlphaComponent(0.14)
        cellShadow.shadowOffset = CGSize(width: 0, height: 0)
        cellShadow.shadowBlurRadius = 2

        //// Variable Declarations
        let opacity: CGFloat = enabled ? 1 : 0.3

        //// Rectangle Drawing
        context.saveGState()
        context.setAlpha(opacity)
        context.beginTransparencyLayer(auxiliaryInfo: nil)

        let rectangleRect = CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: frame.height)
        let rectanglePath = UIBezierPath(roundedRect: rectangleRect, cornerRadius: 4)
        context.saveGState()
        context.setShadow(offset: cellShadow.shadowOffset, blur: cellShadow.shadowBlurRadius, color: (cellShadow.shadowColor as! UIColor).cgColor)
        context.beginTransparencyLayer(auxiliaryInfo: nil)
        rectanglePath.addClip()
        let rectangleRotatedPath = UIBezierPath()
        rectangleRotatedPath.append(rectanglePath)
        var rectangleTransform = CGAffineTransform(rotationAngle: -45 * -CGFloat.pi / 180)
        rectangleRotatedPath.apply(rectangleTransform)
        let rectangleBounds = rectangleRotatedPath.cgPath.boundingBoxOfPath
        rectangleTransform = rectangleTransform.inverted()
        context.drawLinearGradient(redButtonGradient,
                                   start: CGPoint(x: rectangleBounds.minX, y: rectangleBounds.midY).applying(rectangleTransform),
                                   end: CGPoint(x: rectangleBounds.maxX, y: rectangleBounds.midY).applying(rectangleTransform),
                                   options: [])
        context.endTransparencyLayer()
        context.restoreGState()

        let rectangleStyle = NSMutableParagraphStyle()
        rectangleStyle.alignment = .center
        let rectangleFontAttributes = [
            .font: UIFont.boldSystemFont(ofSize: UIFont.systemFontSize),
            .foregroundColor: white,
            .paragraphStyle: rectangleStyle,
        ] as [NSAttributedStringKey: Any]

        let rectangleTextHeight: CGFloat = redButtonText.boundingRect(with: CGSize(width: rectangleRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: rectangleFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: rectangleRect)
        redButtonText.draw(in: CGRect(x: rectangleRect.minX, y: rectangleRect.minY + (rectangleRect.height - rectangleTextHeight) / 2, width: rectangleRect.width, height: rectangleTextHeight), withAttributes: rectangleFontAttributes)
        context.restoreGState()

        context.endTransparencyLayer()
        context.restoreGState()
    }

    @objc public dynamic class func drawTripCanvas(frame: CGRect = CGRect(x: 21, y: 26, width: 12, height: 52)) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Color Declarations
        let fillColor = UIColor(red: 0.078, green: 0.294, blue: 0.533, alpha: 1.000)
        let tripCanvasColor = UIColor(red: 0.078, green: 0.294, blue: 0.533, alpha: 1.000)

        //// Subframes
        let destinationMarker: CGRect = CGRect(x: frame.minX + 1, y: frame.minY + frame.height - 15, width: 9, height: 14)

        //// DestinationMarker
        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 3.45))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 3.24, y: destinationMarker.minY + 4.8), controlPoint1: CGPoint(x: destinationMarker.minX + 3.8, y: destinationMarker.minY + 3.45), controlPoint2: CGPoint(x: destinationMarker.minX + 3.24, y: destinationMarker.minY + 4.06))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 6.15), controlPoint1: CGPoint(x: destinationMarker.minX + 3.24, y: destinationMarker.minY + 5.55), controlPoint2: CGPoint(x: destinationMarker.minX + 3.8, y: destinationMarker.minY + 6.15))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 5.76, y: destinationMarker.minY + 4.8), controlPoint1: CGPoint(x: destinationMarker.minX + 5.2, y: destinationMarker.minY + 6.15), controlPoint2: CGPoint(x: destinationMarker.minX + 5.76, y: destinationMarker.minY + 5.55))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 3.45), controlPoint1: CGPoint(x: destinationMarker.minX + 5.76, y: destinationMarker.minY + 4.06), controlPoint2: CGPoint(x: destinationMarker.minX + 5.2, y: destinationMarker.minY + 3.45))
        bezier2Path.addLine(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 3.45))
        bezier2Path.close()
        bezier2Path.move(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 6.73))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 2.7, y: destinationMarker.minY + 4.8), controlPoint1: CGPoint(x: destinationMarker.minX + 3.51, y: destinationMarker.minY + 6.73), controlPoint2: CGPoint(x: destinationMarker.minX + 2.7, y: destinationMarker.minY + 5.87))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 2.88), controlPoint1: CGPoint(x: destinationMarker.minX + 2.7, y: destinationMarker.minY + 3.74), controlPoint2: CGPoint(x: destinationMarker.minX + 3.51, y: destinationMarker.minY + 2.88))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 6.3, y: destinationMarker.minY + 4.8), controlPoint1: CGPoint(x: destinationMarker.minX + 5.49, y: destinationMarker.minY + 2.88), controlPoint2: CGPoint(x: destinationMarker.minX + 6.3, y: destinationMarker.minY + 3.74))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 6.73), controlPoint1: CGPoint(x: destinationMarker.minX + 6.3, y: destinationMarker.minY + 5.87), controlPoint2: CGPoint(x: destinationMarker.minX + 5.49, y: destinationMarker.minY + 6.73))
        bezier2Path.addLine(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 6.73))
        bezier2Path.close()
        bezier2Path.move(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 0.58))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 0.54, y: destinationMarker.minY + 4.82), controlPoint1: CGPoint(x: destinationMarker.minX + 2.32, y: destinationMarker.minY + 0.58), controlPoint2: CGPoint(x: destinationMarker.minX + 0.54, y: destinationMarker.minY + 2.48))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 0.93, y: destinationMarker.minY + 6.66), controlPoint1: CGPoint(x: destinationMarker.minX + 0.54, y: destinationMarker.minY + 5.44), controlPoint2: CGPoint(x: destinationMarker.minX + 0.66, y: destinationMarker.minY + 6.02))
        bezier2Path.addLine(to: CGPoint(x: destinationMarker.minX + 0.99, y: destinationMarker.minY + 6.78))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.46, y: destinationMarker.minY + 12.84), controlPoint1: CGPoint(x: destinationMarker.minX + 1.04, y: destinationMarker.minY + 6.88), controlPoint2: CGPoint(x: destinationMarker.minX + 2.77, y: destinationMarker.minY + 9.9))
        bezier2Path.addLine(to: CGPoint(x: destinationMarker.minX + 4.49, y: destinationMarker.minY + 12.9))
        bezier2Path.addLine(to: CGPoint(x: destinationMarker.minX + 4.53, y: destinationMarker.minY + 12.84))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 8.01, y: destinationMarker.minY + 6.78), controlPoint1: CGPoint(x: destinationMarker.minX + 6.22, y: destinationMarker.minY + 9.91), controlPoint2: CGPoint(x: destinationMarker.minX + 7.95, y: destinationMarker.minY + 6.9))
        bezier2Path.addLine(to: CGPoint(x: destinationMarker.minX + 8.07, y: destinationMarker.minY + 6.66))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 8.46, y: destinationMarker.minY + 4.82), controlPoint1: CGPoint(x: destinationMarker.minX + 8.34, y: destinationMarker.minY + 6.03), controlPoint2: CGPoint(x: destinationMarker.minX + 8.46, y: destinationMarker.minY + 5.44))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 0.58), controlPoint1: CGPoint(x: destinationMarker.minX + 8.46, y: destinationMarker.minY + 2.48), controlPoint2: CGPoint(x: destinationMarker.minX + 6.68, y: destinationMarker.minY + 0.58))
        bezier2Path.addLine(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 0.58))
        bezier2Path.close()
        bezier2Path.move(to: CGPoint(x: destinationMarker.minX + 4.38, y: destinationMarker.minY + 13.82))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 0.56, y: destinationMarker.minY + 7.13), controlPoint1: CGPoint(x: destinationMarker.minX + 4.23, y: destinationMarker.minY + 13.55), controlPoint2: CGPoint(x: destinationMarker.minX + 0.63, y: destinationMarker.minY + 7.27))
        bezier2Path.addLine(to: CGPoint(x: destinationMarker.minX + 0.44, y: destinationMarker.minY + 6.9))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX, y: destinationMarker.minY + 4.82), controlPoint1: CGPoint(x: destinationMarker.minX + 0.14, y: destinationMarker.minY + 6.19), controlPoint2: CGPoint(x: destinationMarker.minX, y: destinationMarker.minY + 5.52))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY), controlPoint1: CGPoint(x: destinationMarker.minX, y: destinationMarker.minY + 2.16), controlPoint2: CGPoint(x: destinationMarker.minX + 2.02, y: destinationMarker.minY))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 9, y: destinationMarker.minY + 4.82), controlPoint1: CGPoint(x: destinationMarker.minX + 6.98, y: destinationMarker.minY), controlPoint2: CGPoint(x: destinationMarker.minX + 9, y: destinationMarker.minY + 2.16))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 8.57, y: destinationMarker.minY + 6.88), controlPoint1: CGPoint(x: destinationMarker.minX + 9, y: destinationMarker.minY + 5.52), controlPoint2: CGPoint(x: destinationMarker.minX + 8.86, y: destinationMarker.minY + 6.17))
        bezier2Path.addLine(to: CGPoint(x: destinationMarker.minX + 8.45, y: destinationMarker.minY + 7.13))
        bezier2Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.62, y: destinationMarker.minY + 13.77), controlPoint1: CGPoint(x: destinationMarker.minX + 8.37, y: destinationMarker.minY + 7.28), controlPoint2: CGPoint(x: destinationMarker.minX + 5.75, y: destinationMarker.minY + 11.82))
        bezier2Path.addLine(to: CGPoint(x: destinationMarker.minX + 4.49, y: destinationMarker.minY + 14))
        bezier2Path.addLine(to: CGPoint(x: destinationMarker.minX + 4.38, y: destinationMarker.minY + 13.82))
        bezier2Path.close()
        bezier2Path.usesEvenOddFillRule = true
        fillColor.setFill()
        bezier2Path.fill()

        //// Bezier 3 Drawing
        let bezier3Path = UIBezierPath()
        bezier3Path.move(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 3.45))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 3.24, y: destinationMarker.minY + 4.8), controlPoint1: CGPoint(x: destinationMarker.minX + 3.8, y: destinationMarker.minY + 3.45), controlPoint2: CGPoint(x: destinationMarker.minX + 3.24, y: destinationMarker.minY + 4.06))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 6.15), controlPoint1: CGPoint(x: destinationMarker.minX + 3.24, y: destinationMarker.minY + 5.55), controlPoint2: CGPoint(x: destinationMarker.minX + 3.8, y: destinationMarker.minY + 6.15))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 5.76, y: destinationMarker.minY + 4.8), controlPoint1: CGPoint(x: destinationMarker.minX + 5.2, y: destinationMarker.minY + 6.15), controlPoint2: CGPoint(x: destinationMarker.minX + 5.76, y: destinationMarker.minY + 5.55))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 3.45), controlPoint1: CGPoint(x: destinationMarker.minX + 5.76, y: destinationMarker.minY + 4.06), controlPoint2: CGPoint(x: destinationMarker.minX + 5.2, y: destinationMarker.minY + 3.45))
        bezier3Path.addLine(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 3.45))
        bezier3Path.close()
        bezier3Path.move(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 6.73))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 2.7, y: destinationMarker.minY + 4.8), controlPoint1: CGPoint(x: destinationMarker.minX + 3.51, y: destinationMarker.minY + 6.73), controlPoint2: CGPoint(x: destinationMarker.minX + 2.7, y: destinationMarker.minY + 5.87))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 2.88), controlPoint1: CGPoint(x: destinationMarker.minX + 2.7, y: destinationMarker.minY + 3.74), controlPoint2: CGPoint(x: destinationMarker.minX + 3.51, y: destinationMarker.minY + 2.88))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 6.3, y: destinationMarker.minY + 4.8), controlPoint1: CGPoint(x: destinationMarker.minX + 5.49, y: destinationMarker.minY + 2.88), controlPoint2: CGPoint(x: destinationMarker.minX + 6.3, y: destinationMarker.minY + 3.74))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 6.73), controlPoint1: CGPoint(x: destinationMarker.minX + 6.3, y: destinationMarker.minY + 5.87), controlPoint2: CGPoint(x: destinationMarker.minX + 5.49, y: destinationMarker.minY + 6.73))
        bezier3Path.addLine(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 6.73))
        bezier3Path.close()
        bezier3Path.move(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 0.58))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 0.54, y: destinationMarker.minY + 4.82), controlPoint1: CGPoint(x: destinationMarker.minX + 2.32, y: destinationMarker.minY + 0.58), controlPoint2: CGPoint(x: destinationMarker.minX + 0.54, y: destinationMarker.minY + 2.48))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 0.93, y: destinationMarker.minY + 6.66), controlPoint1: CGPoint(x: destinationMarker.minX + 0.54, y: destinationMarker.minY + 5.44), controlPoint2: CGPoint(x: destinationMarker.minX + 0.66, y: destinationMarker.minY + 6.02))
        bezier3Path.addLine(to: CGPoint(x: destinationMarker.minX + 0.99, y: destinationMarker.minY + 6.78))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.46, y: destinationMarker.minY + 12.84), controlPoint1: CGPoint(x: destinationMarker.minX + 1.04, y: destinationMarker.minY + 6.88), controlPoint2: CGPoint(x: destinationMarker.minX + 2.77, y: destinationMarker.minY + 9.9))
        bezier3Path.addLine(to: CGPoint(x: destinationMarker.minX + 4.49, y: destinationMarker.minY + 12.9))
        bezier3Path.addLine(to: CGPoint(x: destinationMarker.minX + 4.53, y: destinationMarker.minY + 12.84))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 8.01, y: destinationMarker.minY + 6.78), controlPoint1: CGPoint(x: destinationMarker.minX + 6.22, y: destinationMarker.minY + 9.91), controlPoint2: CGPoint(x: destinationMarker.minX + 7.95, y: destinationMarker.minY + 6.9))
        bezier3Path.addLine(to: CGPoint(x: destinationMarker.minX + 8.07, y: destinationMarker.minY + 6.66))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 8.46, y: destinationMarker.minY + 4.82), controlPoint1: CGPoint(x: destinationMarker.minX + 8.34, y: destinationMarker.minY + 6.03), controlPoint2: CGPoint(x: destinationMarker.minX + 8.46, y: destinationMarker.minY + 5.44))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 0.58), controlPoint1: CGPoint(x: destinationMarker.minX + 8.46, y: destinationMarker.minY + 2.48), controlPoint2: CGPoint(x: destinationMarker.minX + 6.68, y: destinationMarker.minY + 0.58))
        bezier3Path.addLine(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY + 0.58))
        bezier3Path.close()
        bezier3Path.move(to: CGPoint(x: destinationMarker.minX + 4.38, y: destinationMarker.minY + 13.82))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 0.56, y: destinationMarker.minY + 7.13), controlPoint1: CGPoint(x: destinationMarker.minX + 4.23, y: destinationMarker.minY + 13.55), controlPoint2: CGPoint(x: destinationMarker.minX + 0.63, y: destinationMarker.minY + 7.27))
        bezier3Path.addLine(to: CGPoint(x: destinationMarker.minX + 0.44, y: destinationMarker.minY + 6.9))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX, y: destinationMarker.minY + 4.82), controlPoint1: CGPoint(x: destinationMarker.minX + 0.14, y: destinationMarker.minY + 6.19), controlPoint2: CGPoint(x: destinationMarker.minX, y: destinationMarker.minY + 5.52))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.5, y: destinationMarker.minY), controlPoint1: CGPoint(x: destinationMarker.minX, y: destinationMarker.minY + 2.16), controlPoint2: CGPoint(x: destinationMarker.minX + 2.02, y: destinationMarker.minY))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 9, y: destinationMarker.minY + 4.82), controlPoint1: CGPoint(x: destinationMarker.minX + 6.98, y: destinationMarker.minY), controlPoint2: CGPoint(x: destinationMarker.minX + 9, y: destinationMarker.minY + 2.16))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 8.57, y: destinationMarker.minY + 6.88), controlPoint1: CGPoint(x: destinationMarker.minX + 9, y: destinationMarker.minY + 5.52), controlPoint2: CGPoint(x: destinationMarker.minX + 8.86, y: destinationMarker.minY + 6.17))
        bezier3Path.addLine(to: CGPoint(x: destinationMarker.minX + 8.45, y: destinationMarker.minY + 7.13))
        bezier3Path.addCurve(to: CGPoint(x: destinationMarker.minX + 4.62, y: destinationMarker.minY + 13.77), controlPoint1: CGPoint(x: destinationMarker.minX + 8.37, y: destinationMarker.minY + 7.28), controlPoint2: CGPoint(x: destinationMarker.minX + 5.75, y: destinationMarker.minY + 11.82))
        bezier3Path.addLine(to: CGPoint(x: destinationMarker.minX + 4.49, y: destinationMarker.minY + 14))
        bezier3Path.addLine(to: CGPoint(x: destinationMarker.minX + 4.38, y: destinationMarker.minY + 13.82))
        bezier3Path.close()
        tripCanvasColor.setStroke()
        bezier3Path.lineWidth = 0.3
        bezier3Path.stroke()

        //// TripStart Drawing
        let tripStartPath = UIBezierPath(ovalIn: CGRect(x: frame.minX + 1, y: frame.minY + 1, width: 9, height: 9))
        tripCanvasColor.setStroke()
        tripStartPath.lineWidth = 1
        tripStartPath.stroke()

        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: frame.minX + 5.43, y: frame.minY + 9.92))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 5.43, y: frame.maxY - 15.99))
        tripCanvasColor.setStroke()
        bezierPath.lineWidth = 1
        context.saveGState()
        context.setLineDash(phase: 0, lengths: [2, 2])
        bezierPath.stroke()
        context.restoreGState()
    }

    @objc public dynamic class func drawAlertView(alertViewFrame: CGRect = CGRect(x: 0, y: 0, width: 100, height: 100)) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Color Declarations
        let alertBurntOrange1 = UIColor(red: 0.800, green: 0.320, blue: 0.320, alpha: 1.000)
        let alertBurntOrange2 = UIColor(red: 0.851, green: 0.388, blue: 0.251, alpha: 1.000)
        let alertBurntOrange3 = UIColor(red: 0.914, green: 0.541, blue: 0.427, alpha: 1.000)
        let alertBurntOrange4 = UIColor(red: 0.961, green: 0.694, blue: 0.612, alpha: 1.000)
        let alertBurntOrange5 = UIColor(red: 0.988, green: 0.847, blue: 0.800, alpha: 1.000)

        //// Gradient Declarations
        let alertOrange = CGGradient(colorsSpace: nil, colors: [alertBurntOrange1.cgColor, alertBurntOrange2.cgColor, alertBurntOrange3.cgColor, alertBurntOrange4.cgColor, alertBurntOrange5.cgColor, UIColor.white.cgColor] as CFArray, locations: [0, 0.2, 0.4, 0.6, 0.76, 1])!

        //// Rectangle Drawing
        context.saveGState()
        context.setAlpha(0.2)

        let rectangleRect = CGRect(x: alertViewFrame.minX, y: alertViewFrame.minY, width: alertViewFrame.width, height: alertViewFrame.height)
        let rectanglePath = UIBezierPath(rect: rectangleRect)
        context.saveGState()
        rectanglePath.addClip()
        context.drawLinearGradient(alertOrange,
                                   start: CGPoint(x: rectangleRect.maxX, y: rectangleRect.midY),
                                   end: CGPoint(x: rectangleRect.minX, y: rectangleRect.midY),
                                   options: [])
        context.restoreGState()

        context.restoreGState()
    }

    @objc public dynamic class func drawReverseTripButton(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 60, height: 25), resizing: ResizingBehavior = .aspectFit, buttonHighlighted: Bool = false) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 60, height: 25), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 60, y: resizedFrame.height / 25)

        //// Color Declarations
        let fillColor = UIColor(red: 0.078, green: 0.294, blue: 0.533, alpha: 1.000)
        let blueTextColor = UIColor(red: 0.078, green: 0.294, blue: 0.533, alpha: 1.000)
        let strokeColor = UIColor(red: 0.078, green: 0.294, blue: 0.533, alpha: 1.000)
        let buttonHighlight = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 0.078)
        let buttonDefault = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.000)

        //// Variable Declarations
        let buttonHighlightedColor = buttonHighlighted ? buttonHighlight : buttonDefault

        //// background Drawing
        let backgroundPath = UIBezierPath(roundedRect: CGRect(x: 0.08, y: 0, width: 63.39, height: 23.81), cornerRadius: 3)
        buttonHighlightedColor.setFill()
        backgroundPath.fill()

        //// nextToArriveLabel Drawing
        let nextToArriveLabelRect = CGRect(x: 0, y: -0.15, width: 38.75, height: 23.35)
        let nextToArriveLabelTextContent = "Reverse Trip"
        let nextToArriveLabelStyle = NSMutableParagraphStyle()
        nextToArriveLabelStyle.alignment = .right
        let nextToArriveLabelFontAttributes = [
            .font: UIFont.systemFont(ofSize: 10),
            .foregroundColor: blueTextColor,
            .paragraphStyle: nextToArriveLabelStyle,
        ] as [NSAttributedStringKey: Any]

        let nextToArriveLabelTextHeight: CGFloat = nextToArriveLabelTextContent.boundingRect(with: CGSize(width: nextToArriveLabelRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: nextToArriveLabelFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: nextToArriveLabelRect)
        nextToArriveLabelTextContent.draw(in: CGRect(x: nextToArriveLabelRect.minX, y: nextToArriveLabelRect.minY + (nextToArriveLabelRect.height - nextToArriveLabelTextHeight) / 2, width: nextToArriveLabelRect.width, height: nextToArriveLabelTextHeight), withAttributes: nextToArriveLabelFontAttributes)
        context.restoreGState()

        //// Bezier 9 Drawing
        let bezier9Path = UIBezierPath()
        UIColor.black.setStroke()
        bezier9Path.lineWidth = 1
        bezier9Path.stroke()

        //// reverseIcon.pdf Group
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 54.03, y: 3.75))
        bezierPath.addLine(to: CGPoint(x: 54.03, y: 21.75))
        bezierPath.addLine(to: CGPoint(x: 59.03, y: 17.71))
        bezierPath.addLine(to: CGPoint(x: 58.5, y: 16.95))
        bezierPath.addLine(to: CGPoint(x: 54.97, y: 19.8))
        bezierPath.addLine(to: CGPoint(x: 54.97, y: 3.75))
        bezierPath.addLine(to: CGPoint(x: 54.03, y: 3.75))
        bezierPath.close()
        bezierPath.usesEvenOddFillRule = true
        fillColor.setFill()
        bezierPath.fill()

        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: 54.03, y: 3.75))
        bezier2Path.addLine(to: CGPoint(x: 54.03, y: 21.75))
        bezier2Path.addLine(to: CGPoint(x: 59.03, y: 17.71))
        bezier2Path.addLine(to: CGPoint(x: 58.5, y: 16.95))
        bezier2Path.addLine(to: CGPoint(x: 54.97, y: 19.8))
        bezier2Path.addLine(to: CGPoint(x: 54.97, y: 3.75))
        bezier2Path.addLine(to: CGPoint(x: 54.03, y: 3.75))
        bezier2Path.close()
        strokeColor.setStroke()
        bezier2Path.lineWidth = 0.5
        bezier2Path.stroke()

        //// Bezier 3 Drawing
        let bezier3Path = UIBezierPath()
        bezier3Path.move(to: CGPoint(x: 45.03, y: 7.8))
        bezier3Path.addLine(to: CGPoint(x: 45.55, y: 8.57))
        bezier3Path.addLine(to: CGPoint(x: 49.1, y: 5.71))
        bezier3Path.addLine(to: CGPoint(x: 49.1, y: 21.75))
        bezier3Path.addLine(to: CGPoint(x: 50.03, y: 21.75))
        bezier3Path.addLine(to: CGPoint(x: 50.03, y: 3.75))
        bezier3Path.addLine(to: CGPoint(x: 45.03, y: 7.8))
        bezier3Path.close()
        bezier3Path.usesEvenOddFillRule = true
        fillColor.setFill()
        bezier3Path.fill()

        //// Bezier 4 Drawing
        let bezier4Path = UIBezierPath()
        bezier4Path.move(to: CGPoint(x: 45.03, y: 7.8))
        bezier4Path.addLine(to: CGPoint(x: 45.55, y: 8.57))
        bezier4Path.addLine(to: CGPoint(x: 49.1, y: 5.71))
        bezier4Path.addLine(to: CGPoint(x: 49.1, y: 21.75))
        bezier4Path.addLine(to: CGPoint(x: 50.03, y: 21.75))
        bezier4Path.addLine(to: CGPoint(x: 50.03, y: 3.75))
        bezier4Path.addLine(to: CGPoint(x: 45.03, y: 7.8))
        bezier4Path.close()
        strokeColor.setStroke()
        bezier4Path.lineWidth = 0.5
        bezier4Path.stroke()

        context.restoreGState()
    }

    @objc public dynamic class func drawNextToArriveButton(buttonFrame: CGRect = CGRect(x: 3.94, y: 3.28, width: 240.51, height: 64.69)) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }

        //// Color Declarations
        let redButtonGradientLeft = UIColor(red: 0.502, green: 0.153, blue: 0.063, alpha: 1.000)
        let redButtonGradientRight1 = UIColor(red: 0.843, green: 0.227, blue: 0.071, alpha: 1.000)
        let fillColor2 = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)

        //// Gradient Declarations
        let redButtonGradient = CGGradient(colorsSpace: nil, colors: [redButtonGradientLeft.cgColor, redButtonGradientRight1.cgColor] as CFArray, locations: [0, 1])!

        //// Shadow Declarations
        let testShadow = NSShadow()
        testShadow.shadowColor = UIColor.green
        testShadow.shadowOffset = CGSize(width: 0, height: 0)
        testShadow.shadowBlurRadius = 5

        //// Subframes
        let textFrame = CGRect(x: buttonFrame.minX + fastFloor((buttonFrame.width - 224) * 0.75403 + 0.05) + 0.45, y: buttonFrame.minY + fastFloor((buttonFrame.height - 28.46) * 0.53337 + 0.17) + 0.33, width: 224, height: 28.46)

        //// Rectangle Drawing
        context.saveGState()
        context.translateBy(x: textFrame.minX + 107.8, y: textFrame.minY + 13.02)

        let rectangleRect = CGRect(x: -120.26, y: -32.35, width: 240.51, height: 64.69)
        let rectanglePath = UIBezierPath(roundedRect: rectangleRect, cornerRadius: 4)
        context.saveGState()
        context.setShadow(offset: testShadow.shadowOffset, blur: testShadow.shadowBlurRadius, color: (testShadow.shadowColor as! UIColor).cgColor)
        context.beginTransparencyLayer(auxiliaryInfo: nil)
        rectanglePath.addClip()
        context.drawLinearGradient(redButtonGradient,
                                   start: CGPoint(x: rectangleRect.minX, y: rectangleRect.midY),
                                   end: CGPoint(x: rectangleRect.maxX, y: rectangleRect.midY),
                                   options: [])
        context.endTransparencyLayer()
        context.restoreGState()

        context.restoreGState()

        //// Text Drawing
        let textRect = CGRect(x: textFrame.minX + 35.05, y: textFrame.minY, width: 189.71, height: 28.46)
        let textTextContent = "Next to Arrive for this Route"
        let textStyle = NSMutableParagraphStyle()
        textStyle.alignment = .left
        let textFontAttributes = [
            .font: UIFont.boldSystemFont(ofSize: UIFont.systemFontSize),
            .foregroundColor: UIColor.white,
            .paragraphStyle: textStyle,
        ] as [NSAttributedStringKey: Any]

        let textTextHeight: CGFloat = textTextContent.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textRect)
        textTextContent.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
        context.restoreGState()

        //// Group
        //// Icon
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: textFrame.minX + 15.89, y: textFrame.minY + 25.06))
        bezierPath.addCurve(to: CGPoint(x: textFrame.minX + 6.94, y: textFrame.minY + 16.36), controlPoint1: CGPoint(x: textFrame.minX + 10.95, y: textFrame.minY + 25.06), controlPoint2: CGPoint(x: textFrame.minX + 6.94, y: textFrame.minY + 21.16))
        bezierPath.addCurve(to: CGPoint(x: textFrame.minX + 15.89, y: textFrame.minY + 7.67), controlPoint1: CGPoint(x: textFrame.minX + 6.94, y: textFrame.minY + 11.57), controlPoint2: CGPoint(x: textFrame.minX + 10.95, y: textFrame.minY + 7.67))
        bezierPath.addCurve(to: CGPoint(x: textFrame.minX + 24.84, y: textFrame.minY + 16.36), controlPoint1: CGPoint(x: textFrame.minX + 20.82, y: textFrame.minY + 7.67), controlPoint2: CGPoint(x: textFrame.minX + 24.84, y: textFrame.minY + 11.57))
        bezierPath.addCurve(to: CGPoint(x: textFrame.minX + 15.89, y: textFrame.minY + 25.06), controlPoint1: CGPoint(x: textFrame.minX + 24.84, y: textFrame.minY + 21.16), controlPoint2: CGPoint(x: textFrame.minX + 20.82, y: textFrame.minY + 25.06))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: textFrame.minX + 15.99, y: textFrame.minY + 18.1))
        bezierPath.addCurve(to: CGPoint(x: textFrame.minX + 17.88, y: textFrame.minY + 16.24), controlPoint1: CGPoint(x: textFrame.minX + 17.03, y: textFrame.minY + 18.1), controlPoint2: CGPoint(x: textFrame.minX + 17.88, y: textFrame.minY + 17.27))
        bezierPath.addCurve(to: CGPoint(x: textFrame.minX + 17.73, y: textFrame.minY + 15.54), controlPoint1: CGPoint(x: textFrame.minX + 17.88, y: textFrame.minY + 16), controlPoint2: CGPoint(x: textFrame.minX + 17.83, y: textFrame.minY + 15.77))
        bezierPath.addLine(to: CGPoint(x: textFrame.minX + 20.16, y: textFrame.minY + 13.15))
        bezierPath.addCurve(to: CGPoint(x: textFrame.minX + 20.16, y: textFrame.minY + 12.21), controlPoint1: CGPoint(x: textFrame.minX + 20.43, y: textFrame.minY + 12.89), controlPoint2: CGPoint(x: textFrame.minX + 20.43, y: textFrame.minY + 12.47))
        bezierPath.addCurve(to: CGPoint(x: textFrame.minX + 19.69, y: textFrame.minY + 12.01), controlPoint1: CGPoint(x: textFrame.minX + 20.04, y: textFrame.minY + 12.08), controlPoint2: CGPoint(x: textFrame.minX + 19.87, y: textFrame.minY + 12.01))
        bezierPath.addCurve(to: CGPoint(x: textFrame.minX + 19.21, y: textFrame.minY + 12.21), controlPoint1: CGPoint(x: textFrame.minX + 19.51, y: textFrame.minY + 12.01), controlPoint2: CGPoint(x: textFrame.minX + 19.34, y: textFrame.minY + 12.08))
        bezierPath.addLine(to: CGPoint(x: textFrame.minX + 16.81, y: textFrame.minY + 14.57))
        bezierPath.addCurve(to: CGPoint(x: textFrame.minX + 15.99, y: textFrame.minY + 14.38), controlPoint1: CGPoint(x: textFrame.minX + 16.55, y: textFrame.minY + 14.45), controlPoint2: CGPoint(x: textFrame.minX + 16.27, y: textFrame.minY + 14.38))
        bezierPath.addCurve(to: CGPoint(x: textFrame.minX + 14.1, y: textFrame.minY + 16.24), controlPoint1: CGPoint(x: textFrame.minX + 14.94, y: textFrame.minY + 14.38), controlPoint2: CGPoint(x: textFrame.minX + 14.1, y: textFrame.minY + 15.22))
        bezierPath.addCurve(to: CGPoint(x: textFrame.minX + 15.99, y: textFrame.minY + 18.1), controlPoint1: CGPoint(x: textFrame.minX + 14.1, y: textFrame.minY + 17.27), controlPoint2: CGPoint(x: textFrame.minX + 14.94, y: textFrame.minY + 18.1))
        bezierPath.close()
        bezierPath.usesEvenOddFillRule = true
        fillColor2.setFill()
        bezierPath.fill()

        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: textFrame.minX + 14.88, y: textFrame.minY + 7.7))
        bezier2Path.addCurve(to: CGPoint(x: textFrame.minX + 14.39, y: textFrame.minY + 7.19), controlPoint1: CGPoint(x: textFrame.minX + 14.61, y: textFrame.minY + 7.7), controlPoint2: CGPoint(x: textFrame.minX + 14.39, y: textFrame.minY + 7.47))
        bezier2Path.addLine(to: CGPoint(x: textFrame.minX + 14.39, y: textFrame.minY + 6.86))
        bezier2Path.addCurve(to: CGPoint(x: textFrame.minX + 15.23, y: textFrame.minY + 5.96), controlPoint1: CGPoint(x: textFrame.minX + 14.39, y: textFrame.minY + 6.36), controlPoint2: CGPoint(x: textFrame.minX + 14.77, y: textFrame.minY + 5.96))
        bezier2Path.addLine(to: CGPoint(x: textFrame.minX + 17.14, y: textFrame.minY + 5.96))
        bezier2Path.addCurve(to: CGPoint(x: textFrame.minX + 17.97, y: textFrame.minY + 6.86), controlPoint1: CGPoint(x: textFrame.minX + 17.6, y: textFrame.minY + 5.96), controlPoint2: CGPoint(x: textFrame.minX + 17.97, y: textFrame.minY + 6.36))
        bezier2Path.addLine(to: CGPoint(x: textFrame.minX + 17.97, y: textFrame.minY + 7.19))
        bezier2Path.addCurve(to: CGPoint(x: textFrame.minX + 17.49, y: textFrame.minY + 7.7), controlPoint1: CGPoint(x: textFrame.minX + 17.97, y: textFrame.minY + 7.47), controlPoint2: CGPoint(x: textFrame.minX + 17.76, y: textFrame.minY + 7.7))
        bezier2Path.addLine(to: CGPoint(x: textFrame.minX + 14.88, y: textFrame.minY + 7.7))
        bezier2Path.close()
        bezier2Path.usesEvenOddFillRule = true
        fillColor2.setFill()
        bezier2Path.fill()

        //// Bezier 3 Drawing
        let bezier3Path = UIBezierPath()
        bezier3Path.move(to: CGPoint(x: textFrame.minX + 1.54, y: textFrame.minY + 16.83))
        bezier3Path.addCurve(to: CGPoint(x: textFrame.minX + 1, y: textFrame.minY + 16.4), controlPoint1: CGPoint(x: textFrame.minX + 1.24, y: textFrame.minY + 16.83), controlPoint2: CGPoint(x: textFrame.minX + 1, y: textFrame.minY + 16.64))
        bezier3Path.addCurve(to: CGPoint(x: textFrame.minX + 1.54, y: textFrame.minY + 15.96), controlPoint1: CGPoint(x: textFrame.minX + 1, y: textFrame.minY + 16.16), controlPoint2: CGPoint(x: textFrame.minX + 1.24, y: textFrame.minY + 15.96))
        bezier3Path.addLine(to: CGPoint(x: textFrame.minX + 5.83, y: textFrame.minY + 15.96))
        bezier3Path.addCurve(to: CGPoint(x: textFrame.minX + 6.37, y: textFrame.minY + 16.4), controlPoint1: CGPoint(x: textFrame.minX + 6.13, y: textFrame.minY + 15.96), controlPoint2: CGPoint(x: textFrame.minX + 6.37, y: textFrame.minY + 16.16))
        bezier3Path.addCurve(to: CGPoint(x: textFrame.minX + 5.83, y: textFrame.minY + 16.83), controlPoint1: CGPoint(x: textFrame.minX + 6.37, y: textFrame.minY + 16.64), controlPoint2: CGPoint(x: textFrame.minX + 6.13, y: textFrame.minY + 16.83))
        bezier3Path.addLine(to: CGPoint(x: textFrame.minX + 1.54, y: textFrame.minY + 16.83))
        bezier3Path.close()
        bezier3Path.usesEvenOddFillRule = true
        fillColor2.setFill()
        bezier3Path.fill()

        //// Bezier 4 Drawing
        let bezier4Path = UIBezierPath()
        bezier4Path.move(to: CGPoint(x: textFrame.minX + 2.47, y: textFrame.minY + 20.47))
        bezier4Path.addCurve(to: CGPoint(x: textFrame.minX + 1.89, y: textFrame.minY + 20.04), controlPoint1: CGPoint(x: textFrame.minX + 2.15, y: textFrame.minY + 20.47), controlPoint2: CGPoint(x: textFrame.minX + 1.89, y: textFrame.minY + 20.28))
        bezier4Path.addCurve(to: CGPoint(x: textFrame.minX + 2.47, y: textFrame.minY + 19.6), controlPoint1: CGPoint(x: textFrame.minX + 1.89, y: textFrame.minY + 19.8), controlPoint2: CGPoint(x: textFrame.minX + 2.15, y: textFrame.minY + 19.6))
        bezier4Path.addLine(to: CGPoint(x: textFrame.minX + 5.79, y: textFrame.minY + 19.6))
        bezier4Path.addCurve(to: CGPoint(x: textFrame.minX + 6.37, y: textFrame.minY + 20.04), controlPoint1: CGPoint(x: textFrame.minX + 6.11, y: textFrame.minY + 19.6), controlPoint2: CGPoint(x: textFrame.minX + 6.37, y: textFrame.minY + 19.8))
        bezier4Path.addCurve(to: CGPoint(x: textFrame.minX + 5.79, y: textFrame.minY + 20.47), controlPoint1: CGPoint(x: textFrame.minX + 6.37, y: textFrame.minY + 20.28), controlPoint2: CGPoint(x: textFrame.minX + 6.11, y: textFrame.minY + 20.47))
        bezier4Path.addLine(to: CGPoint(x: textFrame.minX + 2.47, y: textFrame.minY + 20.47))
        bezier4Path.close()
        bezier4Path.usesEvenOddFillRule = true
        fillColor2.setFill()
        bezier4Path.fill()

        //// Bezier 5 Drawing
        let bezier5Path = UIBezierPath()
        bezier5Path.move(to: CGPoint(x: textFrame.minX + 2.47, y: textFrame.minY + 14.11))
        bezier5Path.addCurve(to: CGPoint(x: textFrame.minX + 1.89, y: textFrame.minY + 13.67), controlPoint1: CGPoint(x: textFrame.minX + 2.15, y: textFrame.minY + 14.11), controlPoint2: CGPoint(x: textFrame.minX + 1.89, y: textFrame.minY + 13.91))
        bezier5Path.addCurve(to: CGPoint(x: textFrame.minX + 2.47, y: textFrame.minY + 13.24), controlPoint1: CGPoint(x: textFrame.minX + 1.89, y: textFrame.minY + 13.43), controlPoint2: CGPoint(x: textFrame.minX + 2.15, y: textFrame.minY + 13.24))
        bezier5Path.addLine(to: CGPoint(x: textFrame.minX + 5.79, y: textFrame.minY + 13.24))
        bezier5Path.addCurve(to: CGPoint(x: textFrame.minX + 6.37, y: textFrame.minY + 13.67), controlPoint1: CGPoint(x: textFrame.minX + 6.11, y: textFrame.minY + 13.24), controlPoint2: CGPoint(x: textFrame.minX + 6.37, y: textFrame.minY + 13.43))
        bezier5Path.addCurve(to: CGPoint(x: textFrame.minX + 5.79, y: textFrame.minY + 14.11), controlPoint1: CGPoint(x: textFrame.minX + 6.37, y: textFrame.minY + 13.91), controlPoint2: CGPoint(x: textFrame.minX + 6.11, y: textFrame.minY + 14.11))
        bezier5Path.addLine(to: CGPoint(x: textFrame.minX + 2.47, y: textFrame.minY + 14.11))
        bezier5Path.close()
        bezier5Path.usesEvenOddFillRule = true
        fillColor2.setFill()
        bezier5Path.fill()

        //// NextToArriveButtonIcon.pdf Group
    }

    @objc(SeptaDrawResizingBehavior)
    public enum ResizingBehavior: Int {
        case aspectFit /// The content is proportionally resized to fit into the target rectangle.
        case aspectFill /// The content is proportionally resized to completely fill the target rectangle.
        case stretch /// The content is stretched to match the entire target rectangle.
        case center /// The content is centered in the target rectangle, but it is NOT resized.

        public func apply(rect: CGRect, target: CGRect) -> CGRect {
            if rect == target || target == CGRect.zero {
                return rect
            }

            var scales = CGSize.zero
            scales.width = abs(target.width / rect.width)
            scales.height = abs(target.height / rect.height)

            switch self {
            case .aspectFit:
                scales.width = min(scales.width, scales.height)
                scales.height = scales.width
            case .aspectFill:
                scales.width = max(scales.width, scales.height)
                scales.height = scales.width
            case .stretch:
                break
            case .center:
                scales.width = 1
                scales.height = 1
            }

            var result = rect.standardized
            result.size.width *= scales.width
            result.size.height *= scales.height
            result.origin.x = target.minX + (target.width - result.width) / 2
            result.origin.y = target.minY + (target.height - result.height) / 2
            return result
        }
    }
}

private extension UIColor {
    func blended(withFraction fraction: CGFloat, of color: UIColor) -> UIColor {
        var r1: CGFloat = 1, g1: CGFloat = 1, b1: CGFloat = 1, a1: CGFloat = 1
        var r2: CGFloat = 1, g2: CGFloat = 1, b2: CGFloat = 1, a2: CGFloat = 1

        getRed(&r1, green: &g1, blue: &b1, alpha: &a1)
        color.getRed(&r2, green: &g2, blue: &b2, alpha: &a2)

        return UIColor(red: r1 * (1 - fraction) + r2 * fraction,
                       green: g1 * (1 - fraction) + g2 * fraction,
                       blue: b1 * (1 - fraction) + b2 * fraction,
                       alpha: a1 * (1 - fraction) + a2 * fraction)
    }
}
